<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Week 6 – Restructuring data for analysis</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img style="width: 120px; float: left; margin-top: 0px; margin-right: 20px;" src="images/CRUK_CI_logo.png"/>Introduction to R&nbsp;&nbsp;&nbsp;</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Contents
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="week0.html">Week 0 - Getting ready</a>
    </li>
    <li>
      <a href="week1.html">Week 1 - Introduction to R and RStudio</a>
    </li>
    <li>
      <a href="week2.html">Week 2 - Working with data in R</a>
    </li>
    <li>
      <a href="week3.html">Week 3 - Data visualization with ggplot2</a>
    </li>
    <li>
      <a href="week4.html">Week 4 - Data manipulation using dplyr</a>
    </li>
    <li>
      <a href="week5.html">Week 5 - Grouping and combining data</a>
    </li>
    <li>
      <a href="week6.html">Week 6 - Restructuring data for analysis</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/bioinformatics-core-shared-training/r-intro">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Week 6 – Restructuring data for analysis</h1>

</div>


<blockquote>
<h4 id="learning-objectives">Learning objectives</h4>
<ul>
<li>Understand what makes a data set ‘tidy’ and why you’d want your data to be structured this way</li>
<li>Use <code>pivot_longer()</code> and <code>pivot_wider()</code> operations to restructure data frames</li>
<li>Tease apart columns containing multiple variables using <code>separate()</code></li>
<li>Modify character variables using string manipulation functions from the stringr package</li>
<li>Customize non-data components of plots created using ggplot2 by changing the theme</li>
</ul>
</blockquote>
<hr />
<div id="restructuring-data" class="section level1">
<h1>Restructuring data</h1>
<p>The data you collect or obtain from a third party is not always in a form that is suitable for exploratory analysis and visualization and may need to be restructured before you can fully make use of it.</p>
<p>This is particularly true of the plotting and summarizing tools we’ve been looking at in this course, which are designed specifically to work on data in a format referred to as ‘tidy’. This is where the tidyverse gets its name.</p>
<p>In this session, we will look at what it means for data to be ‘tidy’ and how you can transform your data, if necessary, into this form. We’ll also look at useful functions for handling compound variables, that is columns that contain more than one type of measurement or attribute (you’d be surprised how common this is) and some of the string manipulation functions from the stringr package that can help with cleaning up values within a data frame.</p>
<p>Finally, we’ll take another look at customizing plots created with ggplot2 by changing various non-data components that are largely cosmetic.</p>
<p>The functions we’re mostly focusing on in this session are from the <strong>tidyr</strong> and <strong>stringr</strong> packages both of which get loaded as part of the tidyverse.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<hr />
</div>
<div id="tidy-data" class="section level1">
<h1>Tidy data</h1>
<p>So what is ‘tidy data’ and why should we care about it?</p>
<p>To answer these questions, we’ll look at different ways in which a simple data set can be represented and consider the challenges associated with each. The data set in question is a subset of data from the <a href="https://www.who.int/health-topics/tuberculosis">World Health Organization Global Tuberculosis Report</a>.</p>
<p>The tidyr package contains a series of tibbles that represent the same set of information on the number of new cases of tuberculosis (TB) recorded in each of 3 countries in the years 1999 and 2000 as well as the populations of those countries.</p>
<p>Here is the first table, <code>table1</code>, that contains a row for every combination of country and year and separate columns containing the numbers of TB cases and the population.</p>
<pre class="r"><code>table1</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<p>Two alternative ways of representing the same information are given in <code>table2</code> and <code>table3</code>. We’ll consider each of these in turn, shortly.</p>
<pre class="r"><code>table2</code></pre>
<pre><code>## # A tibble: 12 x 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
<pre class="r"><code>table3</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583</code></pre>
<p>The final representation has the data split across two tables, a scenario that is actually quite likely given that population data will almost certainly have been collected separately from the recording of TB cases.</p>
<pre class="r"><code>table4a</code></pre>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
<pre class="r"><code>table4b</code></pre>
<pre><code>## # A tibble: 3 x 3
##   country         `1999`     `2000`
## * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan   19987071   20595360
## 2 Brazil       172006362  174504898
## 3 China       1272915272 1280428583</code></pre>
<p>Time series data like this are very commonly represented as they are in <code>table4a</code> and <code>table4b</code> with a series of dates or years as columns extending across a spreadsheet. You will find numerous examples of this if you seek out various data sets made available by the UK Office for National Statistics and various other national and international organizations.</p>
<p>Tables 1 to 4 are all different representations of the same underlying data but one of these tables is structured in such a way as to be most readily used in the tidyverse.</p>
<div id="rules-for-tidy-data" class="section level2">
<h2>Rules for tidy data</h2>
<div class="rmdblock">
<p>
<strong>Tidy data</strong>
</p>
<p>
A tidy data set is a data frame (or table) for which the following are true:
</p>
<ol style="list-style-type: decimal">
<li>
Each <strong>variable</strong> has its own column
</li>
<li>
Each <strong>observation</strong> has its own row
</li>
<li>
Each <strong>value</strong> has its own cell
</li>
</ol>
<div class="figure">
<p><img src="images/tidy_data.png" /></p>
</div>
<p>
A <strong>variable</strong> contains all values that measure the same underlying attribute (like height, temperature, duration) across units.
</p>
<p>
An <strong>observation</strong> contains all values measured on the same unit (like a person or a day) across attributes.
</p>
<p>
<em>From <a href="https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf">‘Tidy Data’</a> by Hadley Wickham.</em>
</p>
</div>
<p><strong>Question:</strong> <em>Which of the above representations of TB cases is tidy?</em></p>
<p>Another way of framing the question is to consider what are the variables in the TB data set, i.e. what are the things that vary and for which we can attach a value for each observation?</p>
<p>Take another look at tables 4a and 4b. Do each of the columns correspond to a variable? The country is certainly a variable. In this data set it takes one of three values: Afghanistan, Brazil or China.</p>
<p>But what about the other two columns, ‘1999’ and ‘2000’? These are values, not variables. The variable in this case would be ‘year’ and could take a value of 1999 or 2000. Tables 4a and 4b are not tidy.</p>
<p>There is also another rather obvious problem with tables 4a and 4b – the data are contained in two separate data frames. The data would almost certainly have been collected separately, so it’s hardly surprising, but whenever numbers of people affected by a disease, or engaging in an activity, are compared between countries we almost always want to be comparing the rate (the percentage within the population) and not the absolute number, so that the comparison is fair. We need to combine the data from these two tables in order to calculate the rate.</p>
<p>The only table that is truly tidy is <code>table1</code>. It contains one column for each of the variables in the data set, namely country, year, the number of new TB cases and the population. We’ll look at tables 2 and 3 shortly and why these aren’t tidy and what we can do about it, but first we’ll see how we can convert tables 4a and 4b into the tidy format.</p>
<hr />
</div>
</div>
<div id="pivoting-operations" class="section level1">
<h1>Pivoting operations</h1>
<div id="pivot_longer" class="section level2">
<h2><code>pivot_longer()</code></h2>
<p>Tables 4a and 4b are examples of what is often referred to as ‘wide format’. While neither table looks especially wide, you can imagine that the more complete WHO data set contains data for very many years and that if each had its own column, the table would be very much wider.</p>
<p>What we need is a column for ‘year’ so that we have a count, whether it is the number of TB cases or the population, for each unique combination of country and year. Transforming the table in this way is known as ‘pivoting’ and the tidyr package provides the <code>pivot_longer()</code> function for just such an operation.</p>
<pre class="r"><code>table4a</code></pre>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
## * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
<pre class="r"><code>table4a_long &lt;- pivot_longer(table4a, c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;)
table4a_long</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country     year   cases
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
## 1 Afghanistan 1999     745
## 2 Afghanistan 2000    2666
## 3 Brazil      1999   37737
## 4 Brazil      2000   80488
## 5 China       1999  212258
## 6 China       2000  213766</code></pre>
<p>As with almost all tidyverse operations the first argument is the data frame we’re working on. The second specifies which columns we are operating on. Here we’ve used a vector with <code>c()</code> but it is also quite customary and normally more convenient to use a range of columns, e.g. <code>`1999`:`2000`</code>. Remember that we have to use backticks because R doesn’t like variable names starting with numbers.</p>
<div class="rmdblock">
<p>
<strong>Pivoting operations</strong>
</p>
<p>
<strong><code>pivot_longer(data, cols, names_to = “name”, values_to = “value”)</code></strong>
</p>
<p>
Pivot data from wide to long, increasing the number of rows and decreasing the number of columns.
</p>
<p>
<code>table4a_long &lt;- pivot_longer(table4a, <code>1999</code>:<code>2000</code>, names_to = “year”, values_to = “cases”)</code>
</p>
<div class="figure">
<p><img src="images/pivot_longer.png" /></p>
</div>
<p>
<strong><code>pivot_wider(data, names_from = name, values_from = value)</code></strong>
</p>
<p>
Pivot data from long to wide, increasing the number of columns and decreasing the number of rows.
</p>
<p>
<code>table4a_wide &lt;- pivot_wider(table4a_long, names_from = “year”, values_from = “cases”)</code>
</p>
</div>
<p>The <code>names_to</code> and <code>values_to</code> arguments are so called because we are taking the names of the columns we specified (1999 and 2000) and putting these in a new column with a name given by <code>names_to</code>. Likewise, we are taking values in each of our specified columns and putting these in a new column whose name is given by <code>values_to</code>.</p>
<p>We can do the same with <code>table4b</code> and join the two resulting tables together to recreate <code>table1</code>.</p>
<pre class="r"><code>table4b_long &lt;- pivot_longer(table4b, c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;population&quot;)
table4b_long</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country     year  population
##   &lt;chr&gt;       &lt;chr&gt;      &lt;int&gt;
## 1 Afghanistan 1999    19987071
## 2 Afghanistan 2000    20595360
## 3 Brazil      1999   172006362
## 4 Brazil      2000   174504898
## 5 China       1999  1272915272
## 6 China       2000  1280428583</code></pre>
<pre class="r"><code>left_join(table4a_long, table4b_long, by = c(&quot;country&quot;, &quot;year&quot;))</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country     year   cases population
##   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan 1999     745   19987071
## 2 Afghanistan 2000    2666   20595360
## 3 Brazil      1999   37737  172006362
## 4 Brazil      2000   80488  174504898
## 5 China       1999  212258 1272915272
## 6 China       2000  213766 1280428583</code></pre>
</div>
<div id="pivot_wider" class="section level2">
<h2><code>pivot_wider()</code></h2>
<p><code>pivot_wider()</code> has the opposite effect of <code>pivot_longer()</code> and can be used to reverse the pivoting operation we just performed on <code>table4a</code>.</p>
<pre class="r"><code>pivot_wider(table4a_long, names_from = &quot;year&quot;, values_from = &quot;cases&quot;)</code></pre>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
##   &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
<p>In some cases the wide format is the more human-readable form and usually it is a more compact way of representing the data. In this example, there is no duplication of the year value in the wide format of <code>table4a</code> and <code>table4b</code>. We will see later that this is much more apparent with larger data tables, e.g. gene expression matrices.</p>
<p>Let’s look again at <code>table2</code>.</p>
<pre class="r"><code>table2</code></pre>
<pre><code>## # A tibble: 12 x 4
##    country      year type            count
##    &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;           &lt;int&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
<p>Are the type and count columns true variables? And what is the observational unit in this case?</p>
<p>If we consider the observational unit to be a country in a specific year then <code>table2</code> is not tidy because observations are split across two rows. Also the count variable contains counts of what are essentially different things, the number of cases of TB or the total population.</p>
<p>In tricky situations like this, a tell-tale sign that the data is not in a tidy format is when we attempt to perform some exploratory data analysis and visualization and find we’re having to do quite a bit of work to calculate or plot what we want.</p>
<p>For example, if we wanted to create a bar plot of the numbers of TB cases in each country, we would have to first remove the rows corresponding to the populations using a filter operation. Surely that wouldn’t be necessary if the data were tidy.</p>
<p>Similarly, the rate of new TB cases, i.e. the proportion of the population infected with TB, is something we should be able to calculate easily in a simple operation. However, this is actually quite difficult to do with the data structured as they are in <code>table2</code>.</p>
<p>We can use <code>pivot_wider()</code> to sort this out. The <code>type</code> column contains the variable names so we’d need to set <code>names_from = &quot;type&quot;</code>, while the values will be taken from the <code>count</code> column.</p>
<pre class="r"><code>table2_fixed &lt;- pivot_wider(table2, names_from = &quot;type&quot;, values_from = &quot;count&quot;)
table2_fixed</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<p>The resulting table is exactly the same as <code>table1</code> and now the rate of infection can be calculated rather straightforwardly.</p>
<pre class="r"><code>mutate(table2_fixed, rate = cases / population)</code></pre>
<pre><code>## # A tibble: 6 x 5
##   country      year  cases population      rate
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;     &lt;dbl&gt;
## 1 Afghanistan  1999    745   19987071 0.0000373
## 2 Afghanistan  2000   2666   20595360 0.000129 
## 3 Brazil       1999  37737  172006362 0.000219 
## 4 Brazil       2000  80488  174504898 0.000461 
## 5 China        1999 212258 1272915272 0.000167 
## 6 China        2000 213766 1280428583 0.000167</code></pre>
<hr />
</div>
</div>
<div id="splitting-columns" class="section level1">
<h1>Splitting columns</h1>
<p>Table 3 contains an example of a column that contains multiple values. It is a somewhat convoluted example but occasionally you may come across data like this.</p>
<pre class="r"><code>table3</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country      year rate             
## * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            
## 1 Afghanistan  1999 745/19987071     
## 2 Afghanistan  2000 2666/20595360    
## 3 Brazil       1999 37737/172006362  
## 4 Brazil       2000 80488/174504898  
## 5 China        1999 212258/1272915272
## 6 China        2000 213766/1280428583</code></pre>
<p>The <code>rate</code> column contains both the number of TB cases and the population separated by a ‘/’ character. The rate column is a character type so not terribly useful for doing anything of a mathematical nature in its current guise.</p>
<div id="separate" class="section level2">
<h2><code>separate()</code></h2>
<p>The <code>separate()</code> function allows us to split a character column into multiple columns based on a delimiter or separator.</p>
<pre class="r"><code>table3_separated &lt;- separate(table3, rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;)
table3_separated</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country      year cases  population
##   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
## 1 Afghanistan  1999 745    19987071  
## 2 Afghanistan  2000 2666   20595360  
## 3 Brazil       1999 37737  172006362 
## 4 Brazil       2000 80488  174504898 
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<p>The <code>sep</code> argument takes a regular expression that defines how to split the values. We’ve mentioned regular expressions before – they are a language for specifying search patterns used to find sequences of characters within text and well worth learning. In this case our separator is just the ‘/’ character.</p>
<p>The resulting data frame is still not quite what we want though. This becomes apparent as soon as we try to do anything with the new <code>cases</code> and <code>population</code> columns.</p>
<pre class="r"><code>mutate(table3_separated, rate = cases / population)</code></pre>
<pre><code>## Error in cases/population: non-numeric argument to binary operator</code></pre>
<p>By default the separated values are character types. We could convert these using <code>mutate_at()</code>.</p>
<pre class="r"><code>mutate_at(table3_separated, vars(cases, population), as.integer)</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
<p>But another option is to specify <code>convert = TRUE</code> when carrying out the <code>separate()</code> operation, in which case it will deduce the type of the values and convert the column accordingly.</p>
<pre class="r"><code>table3_separated &lt;- separate(table3, rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;, convert = TRUE)
mutate(table3_separated, rate = cases / population)</code></pre>
<pre><code>## # A tibble: 6 x 5
##   country      year  cases population      rate
##   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;     &lt;dbl&gt;
## 1 Afghanistan  1999    745   19987071 0.0000373
## 2 Afghanistan  2000   2666   20595360 0.000129 
## 3 Brazil       1999  37737  172006362 0.000219 
## 4 Brazil       2000  80488  174504898 0.000461 
## 5 China        1999 212258 1272915272 0.000167 
## 6 China        2000 213766 1280428583 0.000167</code></pre>
<hr />
</div>
</div>
<div id="example-1-metabric-gene-expression" class="section level1">
<h1>Example 1: METABRIC gene expression</h1>
<p>Although tables 1 to 4 contain real data they are, of course, ‘toy’ data frames created for demonstration and teaching purposes. We’ll now turn our attention to the METABRIC expression data and see how this needs to be transformed into a tidier format to open up different avenues for exploring the data.</p>
<p>We’ll first load the table and then select just the columns we’re going to need.</p>
<pre class="r"><code>metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;) %&gt;%
  select(Patient_ID, ER_status, ESR1:MLPH)
metabric</code></pre>
<pre><code>## # A tibble: 1,904 x 10
##    Patient_ID ER_status  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##    &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000    Positive   8.93  9.33  5.68  6.34   5.70  6.93  7.95  9.73
##  2 MB-0002    Positive  10.0   9.73  7.51  6.19   5.76 11.3  11.8  12.5 
##  3 MB-0005    Positive  10.0   9.73  7.38  6.40   6.75  9.29 11.7  10.3 
##  4 MB-0006    Positive  10.4  10.3   6.82  6.87   7.22  8.67 11.9  10.5 
##  5 MB-0008    Positive  11.3   9.96  7.33  6.34   5.82  9.72 11.6  12.2 
##  6 MB-0010    Positive  11.2   9.74  5.95  5.42   6.12  9.79 12.1  11.4 
##  7 MB-0014    Positive  10.8   9.28  7.72  5.99   7.48  8.37 11.5  10.8 
##  8 MB-0022    Positive  10.4   8.61  5.59  6.17   7.59  7.87 10.7   9.95
##  9 MB-0028    Positive  12.5  10.7   5.33  6.22   6.25 10.3  12.1  10.9 
## 10 MB-0035    Positive   7.54 11.5   5.59  6.41   5.99 10.2  12.8  13.5 
## # … with 1,894 more rows</code></pre>
<p>When we first looked at visualization using ggplot2 we created the following box plot.</p>
<pre class="r"><code>ggplot(metabric) +
  geom_boxplot(mapping = aes(x = ER_status, y = GATA3))</code></pre>
<p><img src="week6_files/figure-html/box_plot_1-1.png" width="480" /></p>
<p>But what if we would like to create a series of plots using the faceting functions in ggplot2 with one plot for each gene?</p>
<p>Faceting requires a categorical variable, which is used to divide the data into subsets to be used for each plot. In this case we’d need a gene column. Clearly our data are not structured in this way.</p>
<p>We have gene names for column headings. Are these variables? Well, maybe, although a more correct name for each of these variables or column headings would be ‘Expression of ESR1’, ‘Expression of ERBB2’, etc.</p>
<p>But we could consider that these gene column headings are actually values of a variable called ‘gene’ or ‘gene symbol’. In this regard, what we have is a ‘wide format’ table.</p>
<p>Most gene expression matrices have a similar form, although usually there have rows for each gene and columns for each sample. It should be said that the gene expression matrix format is a very compact way of representing the data which could be a consideration when dealing with tens of thousands of genes and anywhere between a few tens of samples to a few thousand, such is the case for METABRIC.</p>
<p>Furthermore, there are lots of tools for working with gene expression data in the form of matrices, including many packages in the Bioconductor project. Fortunately, as we’ve seen, <code>pivot_longer()</code> and <code>pivot_wider()</code> provide a very convenient means of converting between tidy and matrix-like formats.</p>
<p>We’ll convert our table of ER status and gene expression data to the tidy format.</p>
<pre class="r"><code>metabric &lt;- pivot_longer(metabric, ESR1:MLPH, names_to = &quot;Gene&quot;, values_to = &quot;Expression&quot;)
metabric</code></pre>
<pre><code>## # A tibble: 15,232 x 4
##    Patient_ID ER_status Gene   Expression
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;
##  1 MB-0000    Positive  ESR1         8.93
##  2 MB-0000    Positive  ERBB2        9.33
##  3 MB-0000    Positive  PGR          5.68
##  4 MB-0000    Positive  TP53         6.34
##  5 MB-0000    Positive  PIK3CA       5.70
##  6 MB-0000    Positive  GATA3        6.93
##  7 MB-0000    Positive  FOXA1        7.95
##  8 MB-0000    Positive  MLPH         9.73
##  9 MB-0002    Positive  ESR1        10.0 
## 10 MB-0002    Positive  ERBB2        9.73
## # … with 15,222 more rows</code></pre>
<p>Note how we specified a range of columns between <code>ESR1</code> and <code>MLPH</code>, which is a lot easier than naming each column individually.</p>
<p>We’re now in a position to create our faceted box plot chart.</p>
<pre class="r"><code>ggplot(data = metabric) +
  geom_boxplot(mapping = aes(x = ER_status, y = Expression)) +
  facet_wrap(vars(Gene))</code></pre>
<p><img src="week6_files/figure-html/box_plot_2-1.png" width="672" /></p>
<p>In carrying out this transformation, the observational unit has changed. The tidy format has <em>one-row-per-gene-per-sample</em>, while wide format was <em>one-row-per-sample</em>. The tidy format is much less compact and involves considerable duplication of values in the first three columns (<code>Patient_ID</code>, <code>ER_status</code> and <code>Gene</code>).</p>
<p>One of the other plot types we’ve used in exploring these data was a scatter plot comparing the expression of two genes across all the samples. For this, the <em>one-row-per-sample</em> representation is the more appropriate and being able to convert back to this format allows us to create the plot.</p>
<pre class="r"><code>metabric %&gt;%
  pivot_wider(names_from = &quot;Gene&quot;, values_from = &quot;Expression&quot;) %&gt;%
  ggplot() +
  geom_point(mapping = aes(x = GATA3, y = ESR1, colour = ER_status))</code></pre>
<p><img src="week6_files/figure-html/scatter_plot_1-1.png" width="672" /></p>
<hr />
</div>
<div id="example-2-protein-levels-in-mcf-7-after-treatment-with-tamoxifen" class="section level1">
<h1>Example 2: Protein levels in MCF-7 after treatment with tamoxifen</h1>
<p>Our second real example features another data set generated by CRUK CI scientists (<a href="https://pubmed.ncbi.nlm.nih.gov/29899353">Papachristou <em>et al.</em>, Nature Communications 9:2311, 2018</a>) in which the dynamics of endogenous chromatin-associated protein complexes were investigated using quantitative mass spectrometry.</p>
<p>We’ll look at just one of several tabular data sets made available as supplementary data, which contains the total level of protein in MCF-7 cells at various time points after treatment with the drug tamoxifen. MCF-7 is a breast cancer cell line isolated in 1970 from a 69-year old woman and established for use in breast cancer research by the Michigan Cancer Foundation-7 institute in Detroit. Tamoxifen is a hormone therapy used in the treatment of estrogen receptor-positive breast cancer.</p>
<p>The table in question is <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5998130/bin/41467_2018_4619_MOESM11_ESM.xlsx">supplementary data 9</a>.</p>
<pre class="r"><code>library(readxl)
protein_levels &lt;- read_excel(&quot;data/41467_2018_4619_MOESM11_ESM.xlsx&quot;, skip = 1)
select(protein_levels, `Uniprot Accession`, `Gene Name`, ends_with(&quot;rep01&quot;))</code></pre>
<pre><code>## # A tibble: 7,943 x 6
##    `Uniprot Access… `Gene Name` vehicle.rep01 tam.2h.rep01 tam.6h.rep01
##    &lt;chr&gt;            &lt;chr&gt;               &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
##  1 Q09666           AHNAK                17.3         17.3         17.3
##  2 P05787           KRT8                 16.9         17.1         17.0
##  3 Q15149           PLEC                 16.7         16.7         16.7
##  4 P21333           FLNA                 16.6         16.5         16.6
##  5 P05783           KRT18                16.4         16.6         16.5
##  6 P49327           FASN                 16.0         16.0         16.0
##  7 P10809           HSPD1                16.1         16.2         16.1
##  8 Q14204           DYNC1H1              16.0         15.9         16.0
##  9 O75369           FLNB                 16.1         16.1         16.2
## 10 P35579           MYH9                 15.7         15.6         15.8
## # … with 7,933 more rows, and 1 more variable: tam.24h.rep01 &lt;dbl&gt;</code></pre>
<p>This has a very similar structure to a gene expression matrix having one row for each protein (or gene) and a column for each sample. We’ve only shown columns for the first of four replicates for each group defined by a treatment and a time point. The control group is, in effect, the ‘untreated’ group in which the cells are treated with the vehicle (ethanol) alone.</p>
<p>If we wanted to calculate the mean protein levels within each group, i.e. the average level for the protein measured in the 4 replicates, or we wanted to show the spread of values for the replicates as a box plot, then the data as currently structured is not in the most suitable form. In what follows, we’ll transform the table to allow us to do both these analyses.</p>
<p>To simplify matters, we’re going to focus on just a few proteins, those whose levels are markedly reduced 24 hours after treatment with tamoxifen compared with the vehicle.</p>
<pre class="r"><code>protein_levels &lt;- protein_levels %&gt;%
  filter(`log2FC(24h/veh)` &lt; -0.75) %&gt;%
  select(accession = `Uniprot Accession`, gene = `Gene Name`, vehicle.rep01:tam.24h.rep04)
protein_levels</code></pre>
<pre><code>## # A tibble: 10 x 18
##    accession gene  vehicle.rep01 tam.2h.rep01 tam.6h.rep01 tam.24h.rep01
##    &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;
##  1 Q4ZG55    GREB1         12.1         12           11.6           9.78
##  2 P15514    AREG          11.4         11.3         11.3           9.92
##  3 Q13433    SLC3…         10.9         10.8         10.7           9.89
##  4 Q9NPD8    UBE2T         10.4         10.3         10.2           9.62
##  5 Q6N021    TET2          10.1         10.0          9.59          8.75
##  6 P06401    PGR            9.97        10.0          9.75          8.75
##  7 P25929    NPY1R          9.08         9.16         8.89          7.94
##  8 O95084    PRSS…          8.45         8.53         8.27          7.78
##  9 P08493    MGP            6.76         6.76         6.18          5.09
## 10 Q96BR1    SGK3           6.33         6.42         6.16          5.5 
## # … with 12 more variables: vehicle.rep02 &lt;dbl&gt;, tam.2h.rep02 &lt;dbl&gt;,
## #   tam.6h.rep02 &lt;dbl&gt;, tam.24h.rep02 &lt;dbl&gt;, vehicle.rep03 &lt;dbl&gt;,
## #   tam.2h.rep03 &lt;dbl&gt;, tam.6h.rep03 &lt;dbl&gt;, tam.24h.rep03 &lt;dbl&gt;,
## #   vehicle.rep04 &lt;dbl&gt;, tam.2h.rep04 &lt;dbl&gt;, tam.6h.rep04 &lt;dbl&gt;,
## #   tam.24h.rep04 &lt;dbl&gt;</code></pre>
<p>This is a fairly typical example of a table with columns for each sample where the sample names contain quite a lot of information, in this case:</p>
<ul>
<li>the treatment</li>
<li>the time at which the protein levels are measured after treatment</li>
<li>the number of the replicate sample for that treatment and time point</li>
</ul>
<p>To make use of this information we need to pivot the table such that the sample name is in a column and protein levels are in another column, and then to split the sample name column into its constituent parts.</p>
<p>For the first part of this transformation we’ll use <code>pivot_longer()</code>.</p>
<pre class="r"><code>protein_levels &lt;- pivot_longer(protein_levels, vehicle.rep01:tam.24h.rep04, names_to = &quot;sample&quot;, values_to = &quot;protein_level&quot;)
protein_levels</code></pre>
<pre><code>## # A tibble: 160 x 4
##    accession gene  sample        protein_level
##    &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;                 &lt;dbl&gt;
##  1 Q4ZG55    GREB1 vehicle.rep01         12.1 
##  2 Q4ZG55    GREB1 tam.2h.rep01          12   
##  3 Q4ZG55    GREB1 tam.6h.rep01          11.6 
##  4 Q4ZG55    GREB1 tam.24h.rep01          9.78
##  5 Q4ZG55    GREB1 vehicle.rep02         11.3 
##  6 Q4ZG55    GREB1 tam.2h.rep02          11.4 
##  7 Q4ZG55    GREB1 tam.6h.rep02          11.1 
##  8 Q4ZG55    GREB1 tam.24h.rep02          8.98
##  9 Q4ZG55    GREB1 vehicle.rep03         11.0 
## 10 Q4ZG55    GREB1 tam.2h.rep03          11.0 
## # … with 150 more rows</code></pre>
<p>Now we can use <code>separate()</code> to disentangle the components of the sample name.</p>
<p>It looks like we need to split on the ‘.’ character but that has a special meaning in a regular expression, i.e. match <em>any</em> character. Fortunately, the default regular expression used by <code>separate()</code> splits on any character that isn’t a letter or a number, so will do just fine.</p>
<p>But there is another problem. The vehicle sample names don’t follow the pattern of “treatment.time.replicate”. In actual fact the vehicle measurements were taken 24 hours after treatment with ethanol alone. What we should do to correct matters is add the ‘24h’ component. For that, we’re going to use one of several really useful string manipulation functions provided by the stringr package.</p>
<div class="rmdblock">
<p>
<strong>Some useful stringr functions</strong>
</p>
<p>
<strong><code>str_c(…, sep = “”)</code></strong>
</p>
<p>
Join multiple strings into a single string.
</p>
<p>
<code>str_c(“tidyverse”, “fab”, sep = &quot; is “)</code>
</p>
<p>
<code>[1] “tidyverse is fab”</code>
</p>
<p>
<code>str_c(c(“Ashley”, “Matt”), c(“hiking”, “beer”), sep = &quot; loves “)</code>
</p>
<p>
<code>[1] “Ashley loves hiking” “Matt loves beer”</code>
</p>
<hr />
<p>
<strong><code>str_replace(string, pattern, replacement)</code></strong>
</p>
<p>
<strong><code>str_replace_all(string, pattern, replacement)</code></strong>
</p>
<p>
Substitute a matched pattern in a string (or character vector).
</p>
<p>
<code>str_replace(“Oscar is the best cat in the world”, “best”, “loveliest”)</code>
</p>
<p>
<code>[1] “Oscar is the loveliest cat in the world”</code>
</p>
<p>
<code>str_replace_all(“the cat sat on the mat”, “at”, “AT”)</code>
</p>
<p>
<code>[1] “the cAT sAT on the mAT”</code>
</p>
<hr />
<p>
<strong><code>str_remove(string, pattern)</code></strong>
</p>
<p>
<strong><code>str_remove_all(string, pattern)</code></strong>
</p>
<p>
Remove matched patterns in a string.
</p>
<p>
Alias for <code>str_replace(string, pattern, “”)</code> and <code>str_replace_all(string, pattern, “”)</code>.
</p>
<hr />
<p>
<strong><code>str_sub(string, start, end)</code></strong>
</p>
<p>
Extract substrings from a character vector at the given start and end positions.
</p>
<p>
<code>str_sub(“Matthew”, start = 1, end = 4)</code>
</p>
<p>
<code>[1] “Matt”</code>
</p>
<p>
<code>str_sub(c(“tamoxifen”, “vehicle”), 1, 3)</code>
</p>
<p>
<code>[1] “tam” “veh”</code>
</p>
</div>
<p><code>str_replace()</code> looks like the function we need so let’s see how it works on our sample names.</p>
<pre class="r"><code>str_replace(&quot;vehicle.rep01&quot;, &quot;vehicle&quot;, &quot;vehicle.24h&quot;)</code></pre>
<pre><code>## [1] &quot;vehicle.24h.rep01&quot;</code></pre>
<p>The first argument is the character vector we’re working on, in this case a single character string. The second argument is the pattern or substring we want to replace and the third is the string we want to replace it with.</p>
<p>Looking at the help we can see that, like very many R functions, it works on a vector of character values (or strings), so let’s try this on a few of our sample names, say the first 10.</p>
<pre class="r"><code>str_replace(protein_levels$sample[1:10], &quot;vehicle&quot;, &quot;vehicle.24h&quot;)</code></pre>
<pre><code>##  [1] &quot;vehicle.24h.rep01&quot; &quot;tam.2h.rep01&quot;      &quot;tam.6h.rep01&quot;     
##  [4] &quot;tam.24h.rep01&quot;     &quot;vehicle.24h.rep02&quot; &quot;tam.2h.rep02&quot;     
##  [7] &quot;tam.6h.rep02&quot;      &quot;tam.24h.rep02&quot;     &quot;vehicle.24h.rep03&quot;
## [10] &quot;tam.2h.rep03&quot;</code></pre>
<p>Finally, we can modify the values in our data frame using <code>mutate()</code>.</p>
<pre class="r"><code>protein_levels &lt;- mutate(protein_levels, sample = str_replace(sample, &quot;vehicle&quot;, &quot;vehicle.24h&quot;))
protein_levels</code></pre>
<pre><code>## # A tibble: 160 x 4
##    accession gene  sample            protein_level
##    &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt;
##  1 Q4ZG55    GREB1 vehicle.24h.rep01         12.1 
##  2 Q4ZG55    GREB1 tam.2h.rep01              12   
##  3 Q4ZG55    GREB1 tam.6h.rep01              11.6 
##  4 Q4ZG55    GREB1 tam.24h.rep01              9.78
##  5 Q4ZG55    GREB1 vehicle.24h.rep02         11.3 
##  6 Q4ZG55    GREB1 tam.2h.rep02              11.4 
##  7 Q4ZG55    GREB1 tam.6h.rep02              11.1 
##  8 Q4ZG55    GREB1 tam.24h.rep02              8.98
##  9 Q4ZG55    GREB1 vehicle.24h.rep03         11.0 
## 10 Q4ZG55    GREB1 tam.2h.rep03              11.0 
## # … with 150 more rows</code></pre>
<p>Now we’re ready to separate the <code>sample</code> column into its component parts.</p>
<pre class="r"><code>protein_levels &lt;- separate(protein_levels, sample, into = c(&quot;treatment&quot;, &quot;time&quot;, &quot;replicate&quot;))
protein_levels</code></pre>
<pre><code>## # A tibble: 160 x 6
##    accession gene  treatment time  replicate protein_level
##    &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt;
##  1 Q4ZG55    GREB1 vehicle   24h   rep01             12.1 
##  2 Q4ZG55    GREB1 tam       2h    rep01             12   
##  3 Q4ZG55    GREB1 tam       6h    rep01             11.6 
##  4 Q4ZG55    GREB1 tam       24h   rep01              9.78
##  5 Q4ZG55    GREB1 vehicle   24h   rep02             11.3 
##  6 Q4ZG55    GREB1 tam       2h    rep02             11.4 
##  7 Q4ZG55    GREB1 tam       6h    rep02             11.1 
##  8 Q4ZG55    GREB1 tam       24h   rep02              8.98
##  9 Q4ZG55    GREB1 vehicle   24h   rep03             11.0 
## 10 Q4ZG55    GREB1 tam       2h    rep03             11.0 
## # … with 150 more rows</code></pre>
<p>The groups we want to compare are in fact the combination of the treatment and the time point. We’ll create a new column called ‘group’ in which we concatenate the treatment and time values using another stringr function, <code>str_c()</code>. But we’ll also shorten ‘vehicle’ to ‘veh’ so we have similar length treatment labels (‘veh’ and ‘tam’) in the plot we’ll eventually create. For that we’ll use <code>str_sub()</code>. Our group variable is categorical so we’ll convert this to a factor while we’re at it.</p>
<pre class="r"><code>protein_levels &lt;- protein_levels %&gt;%
  mutate(group = str_sub(treatment, 1, 3)) %&gt;%
  mutate(group = str_c(group, time)) %&gt;%
  mutate(group = as_factor(group))
protein_levels</code></pre>
<pre><code>## # A tibble: 160 x 7
##    accession gene  treatment time  replicate protein_level group 
##    &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;fct&gt; 
##  1 Q4ZG55    GREB1 vehicle   24h   rep01             12.1  veh24h
##  2 Q4ZG55    GREB1 tam       2h    rep01             12    tam2h 
##  3 Q4ZG55    GREB1 tam       6h    rep01             11.6  tam6h 
##  4 Q4ZG55    GREB1 tam       24h   rep01              9.78 tam24h
##  5 Q4ZG55    GREB1 vehicle   24h   rep02             11.3  veh24h
##  6 Q4ZG55    GREB1 tam       2h    rep02             11.4  tam2h 
##  7 Q4ZG55    GREB1 tam       6h    rep02             11.1  tam6h 
##  8 Q4ZG55    GREB1 tam       24h   rep02              8.98 tam24h
##  9 Q4ZG55    GREB1 vehicle   24h   rep03             11.0  veh24h
## 10 Q4ZG55    GREB1 tam       2h    rep03             11.0  tam2h 
## # … with 150 more rows</code></pre>
<p>Computing the mean protein levels within each group is now very straightforward.</p>
<pre class="r"><code>protein_levels %&gt;%
  group_by(accession, gene, group) %&gt;%
  summarize(protein_level = mean(protein_level))</code></pre>
<pre><code>## # A tibble: 40 x 4
## # Groups:   accession, gene [10]
##    accession gene   group  protein_level
##    &lt;chr&gt;     &lt;chr&gt;  &lt;fct&gt;          &lt;dbl&gt;
##  1 O95084    PRSS23 veh24h          8.16
##  2 O95084    PRSS23 tam2h           8.2 
##  3 O95084    PRSS23 tam6h           8.03
##  4 O95084    PRSS23 tam24h          7.20
##  5 P06401    PGR    veh24h          9.44
##  6 P06401    PGR    tam2h           9.66
##  7 P06401    PGR    tam6h           9.41
##  8 P06401    PGR    tam24h          8.39
##  9 P08493    MGP    veh24h          5.59
## 10 P08493    MGP    tam2h           5.69
## # … with 30 more rows</code></pre>
<p>Plotting the protein levels in each group as box plots with each data point overlaid is only slightly more involved. We can use faceting to create separate plots for each of the proteins (we’ll use gene symbols as they’re more recognizable).</p>
<pre class="r"><code>ggplot(data = protein_levels, mapping = aes(x = group, y = protein_level)) +
  geom_boxplot(colour = &quot;grey60&quot;) +
  geom_jitter(width = 0.15) +
  facet_wrap(vars(gene), scales = &quot;free_y&quot;, ncol = 3)</code></pre>
<p><img src="week6_files/figure-html/box_plot_3-1.png" width="672" /></p>
<hr />
</div>
<div id="further-customization-of-plots-with-ggplot2" class="section level1">
<h1>Further customization of plots with ggplot2</h1>
<p>Finally, we’ll turn our attention back to visualization using ggplot2 and how we can customize our plots by changing the theme and consider various other odds and ends.</p>
<div id="themes" class="section level2">
<h2>Themes</h2>
<p>Themes can be used to customize non-data components of a plot. Let’s create a plot showing the expression of estrogen receptor alpha (ESR1) for each of the Integrative cluster breast cancer subtypes.</p>
<pre class="r"><code># read in the METABRIC data, convert the Integrative_cluster variable into a
# categorical variable with the levels in the correct order, and select just
# the columns and rows we&#39;re going to use
metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;) %&gt;%
  mutate(Integrative_cluster = factor(Integrative_cluster, levels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4ER-&quot;, &quot;4ER+&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;))) %&gt;%
  mutate(`3-gene_classifier` = replace_na(`3-gene_classifier`, &quot;Unclassified&quot;)) %&gt;%
  select(Patient_ID, ER_status, PR_status, `3-gene_classifier`, Integrative_cluster, ESR1) %&gt;%
  filter(!is.na(Integrative_cluster), !is.na(ESR1))
metabric</code></pre>
<pre><code>## # A tibble: 1,904 x 6
##    Patient_ID ER_status PR_status `3-gene_classifie… Integrative_clu…  ESR1
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;              &lt;fct&gt;            &lt;dbl&gt;
##  1 MB-0000    Positive  Negative  ER-/HER2-          4ER+              8.93
##  2 MB-0002    Positive  Positive  ER+/HER2- High Pr… 4ER+             10.0 
##  3 MB-0005    Positive  Positive  Unclassified       3                10.0 
##  4 MB-0006    Positive  Positive  Unclassified       9                10.4 
##  5 MB-0008    Positive  Positive  ER+/HER2- High Pr… 9                11.3 
##  6 MB-0010    Positive  Positive  ER+/HER2- High Pr… 7                11.2 
##  7 MB-0014    Positive  Positive  Unclassified       3                10.8 
##  8 MB-0022    Positive  Negative  Unclassified       3                10.4 
##  9 MB-0028    Positive  Negative  ER+/HER2- High Pr… 9                12.5 
## 10 MB-0035    Positive  Negative  ER+/HER2- High Pr… 3                 7.54
## # … with 1,894 more rows</code></pre>
<pre class="r"><code># plot the ESR1 expression for each integrative cluster
plot &lt;- ggplot(data = metabric) +
  geom_boxplot(mapping = aes(x = Integrative_cluster, y = ESR1, fill = Integrative_cluster)) +
  labs(x = &quot;Integrative cluster&quot;, y = &quot;ESR1 expression&quot;)
plot</code></pre>
<p><img src="week6_files/figure-html/box_plot_4-1.png" width="672" /></p>
<p>The default theme has the characteristic grey background which isn’t particularly suitable for printing on paper. We can change to one of a number of alternative themes available in the ggplot2 package, e.g. the black and white theme.</p>
<pre class="r"><code>plot + theme_bw()</code></pre>
<p><img src="week6_files/figure-html/box_plot_5-1.png" width="672" /></p>
<p>The help page for the available themes, which can be accessed using <code>?theme_bw</code>, lists each and when you might want to use them. It states that <code>black_bw</code> may work better for presentations displayed on a projector.</p>
<p>Each of these themes is really just a collection of attributes relating to how various non-data elements of the plot will be displayed. We can override any of these individual settings using the <code>theme()</code> function. A look at the help page (<code>?theme</code>) shows that there are a very large number of settings that you can change. The following example demonstrates a few of these.</p>
<pre class="r"><code>plot +
  theme_bw() +
  theme(
    panel.grid.major.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = &quot;none&quot;
  )</code></pre>
<p><img src="week6_files/figure-html/box_plot_6-1.png" width="672" /></p>
<p>Here’s another example that also involves customizing the labels, scales and colours.</p>
<pre class="r"><code>ggplot(data = metabric) +
  geom_bar(mapping = aes(x = `3-gene_classifier`, fill = ER_status)) +
  scale_y_continuous(limits = c(0, 700), breaks = seq(0, 700, 100), expand = expand_scale(mult = 0)) +
  scale_fill_manual(values = c(&quot;firebrick2&quot;, &quot;dodgerblue2&quot;)) +
  labs(x = NULL, y = &quot;samples&quot;, fill = &quot;ER status&quot;) +
  theme_bw() +
  theme(
    panel.border = element_blank(),
    panel.grid = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.line.y = element_line(),
    axis.ticks.length.y = unit(0.2, &quot;cm&quot;),
    legend.position = &quot;bottom&quot;
  )</code></pre>
<p><img src="week6_files/figure-html/bar_plot_1-1.png" width="480" /></p>
<p>The ggthemes package contains some extra themes and might be fun to check out. Here’s an example of a plot that uses the <code>theme_gdocs</code> theme that resembles the default look of charts in Google Docs.</p>
<pre class="r"><code>library(ggthemes)
metabric %&gt;%
  filter(`3-gene_classifier` == &quot;HER2+&quot;) %&gt;%
  ggplot(mapping = aes(x = PR_status, y = ESR1)) +
  geom_boxplot() +
  geom_jitter(mapping = aes(colour = PR_status), width = 0.25, alpha = 0.4, show.legend = FALSE) +
  scale_colour_brewer(palette = &quot;Set1&quot;) +
  labs(x = &quot;PR status&quot;, y = &quot;ESR1 expression&quot;) +
  theme_gdocs()</code></pre>
<p><img src="week6_files/figure-html/box_plot_7-1.png" width="480" /></p>
</div>
<div id="position-adjustments" class="section level2">
<h2>Position adjustments</h2>
<p>All geoms in ggplot2 have a position adjustment that can be set using the <code>position</code> argument. This has different effects for different types of plot but essentially this resolves how overlapping geoms are displayed.</p>
<p>For example, let’s consider the stacked bar plot we created earlier showing the numbers of patients in each of the 3-gene classifications subdivided by ER status. The default position value for <code>geom_bar()</code> is “stack” which is why the plot is shown as a stacked bar chart. An alternative way of representing these data would be to show separate bars for each ER status side-by-side by setting <code>position = &quot;dodge&quot;</code>.</p>
<pre class="r"><code>ggplot(data = metabric) +
  geom_bar(mapping = aes(x = `3-gene_classifier`, fill = ER_status), position = &quot;dodge&quot;) +
  scale_y_continuous(limits = c(0, 700), breaks = seq(0, 700, 100), expand = expand_scale(mult = 0)) +
  scale_fill_manual(values = c(&quot;firebrick2&quot;, &quot;dodgerblue2&quot;)) +
  labs(x = NULL, y = &quot;samples&quot;, fill = &quot;ER status&quot;) +
  theme_bw() +
  theme(
    panel.border = element_blank(),
    panel.grid = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.line.y = element_line(),
    axis.ticks.length.y = unit(0.2, &quot;cm&quot;)
  )</code></pre>
<p><img src="week6_files/figure-html/bar_plot_2-1.png" width="672" /></p>
<p>Another position adjustment we’ve come across is <code>geom_jitter()</code>, which is just a convenient shortcut for <code>geom_point(position = &quot;jitter&quot;)</code>. A variation on this, <code>position_jitterdodge()</code>, comes in handy when we are overlaying points on top of a box plot. We show an example of just such a plot in which first use <code>postion = &quot;jitter&quot;</code>.</p>
<pre class="r"><code>metabric %&gt;%
  ggplot(mapping = aes(x = `3-gene_classifier`, y = ESR1, colour = PR_status)) +
  geom_boxplot() +
  geom_point(position = &quot;jitter&quot;, size = 0.5, alpha = 0.3) +
  labs(x = &quot;3-gene classification&quot;, y = &quot;ESR1 expression&quot;, colour = &quot;PR status&quot;) +
  scale_color_brewer(palette = &quot;Set1&quot;) +
  theme_minimal() +
  theme(
    panel.grid.major.x = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.ticks.x = element_blank()
  )</code></pre>
<p><img src="week6_files/figure-html/box_plot_8-1.png" width="672" /></p>
<p>The PR-negative and PR-positive points have distinct colours but are overlapping in a way that is aesthetically displeasing. What we want is for the points to have both jitter and to be dodged in the same way as the boxes. With <code>position_jitterdodge()</code> we get a better looking plot.</p>
<pre class="r"><code>metabric %&gt;%
  ggplot(mapping = aes(x = `3-gene_classifier`, y = ESR1, colour = PR_status)) +
  geom_boxplot() +
  geom_point(position = position_jitterdodge(), size = 0.5, alpha = 0.3) +
  labs(x = &quot;3-gene classification&quot;, y = &quot;ESR1 expression&quot;, colour = &quot;PR status&quot;) +
  scale_color_brewer(palette = &quot;Set1&quot;) +
  theme_minimal() +
  theme(
    panel.grid.major.x = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.ticks.x = element_blank()
  )</code></pre>
<p><img src="week6_files/figure-html/box_plot_9-1.png" width="672" /></p>
</div>
<div id="saving-plot-images" class="section level2">
<h2>Saving plot images</h2>
<p>Use <code>ggsave()</code> to save the last plot you displayed.</p>
<pre class="r"><code>ggsave(&quot;esr1_expression.png&quot;)</code></pre>
<p>You can alter the width and height of the plot and can change the image file type.</p>
<pre class="r"><code>ggsave(&quot;esr1_expression.pdf&quot;, width = 20, height = 12, units = &quot;cm&quot;)</code></pre>
<p>You can also pass in a plot object you have created instead of using the last plot displayed. See the help page (<code>?ggsave</code>) for more details.</p>
<hr />
</div>
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>In this session we have covered the following:</p>
<ul>
<li>Restructuring data frames using pivoting operations</li>
<li>Splitting compound variables into separate columns</li>
<li>Modifying character columns using various string manipulation functions</li>
<li>Customizing plots created with ggplot2 by changing the theme and position adjustments</li>
<li>Saving plots created with ggplot2 as image files</li>
</ul>
<hr />
</div>
<div id="assignment" class="section level1">
<h1>Assignment</h1>
<p>Assignment: <a href="assignments/assignment6.Rmd">assignment6.Rmd</a></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
