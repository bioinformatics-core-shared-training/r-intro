<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Week 5 – Grouping and combining data</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img style="width: 120px; float: left; margin-top: 0px; margin-right: 20px;" src="images/CRUK_CI_logo.png"/>Introduction to R&nbsp;&nbsp;&nbsp;</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Contents
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="week0.html">Week 0 - Getting ready</a>
    </li>
    <li>
      <a href="week1.html">Week 1 - Introduction to R and RStudio</a>
    </li>
    <li>
      <a href="week2.html">Week 2 - Working with data in R</a>
    </li>
    <li>
      <a href="week3.html">Week 3 - Data visualization with ggplot2</a>
    </li>
    <li>
      <a href="week4.html">Week 4 - Data manipulation using dplyr</a>
    </li>
    <li>
      <a href="week5.html">Week 5 - Grouping and combining data</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/bioinformatics-core-shared-training/r-intro">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Week 5 – Grouping and combining data</h1>

</div>


<blockquote>
<h4 id="learning-objectives">Learning objectives</h4>
<ul>
<li>Use <code>group_by()</code> with <code>summarise()</code> to compute summary values for groups of observations</li>
<li>Use <code>count()</code> to count the numbers of observations within categories</li>
<li>Combine data from two tables based on a common identifier (<code>join</code> operations)</li>
<li>Customize plots created using ggplot2 by changing labels, scales and colours</li>
</ul>
</blockquote>
<hr />
<div id="grouping-and-combining-data" class="section level1">
<h1>Grouping and combining data</h1>
<p>In this session, we’ll look at some more useful functions provided by the <strong>dplyr</strong> package, the ‘workhorse’ in the tidyverse family for manipulating tabular data. Continuing from last week, we’ll see how we can summarise data for groups of observations within different categories. We’ll also show how dplyr allows us to combine data for the same observational unit, e.g. person or date, that comes from different sources and is read into R in different tables.</p>
<p>We’ll also look at how to customize the plots we create using <strong>ggplot2</strong>, in particular how we can add or change titles and labels, how we can adjust the way the axes are displayed and how we can use a colour scheme of our choosing.</p>
<p><strong>dplyr</strong> and <strong>ggplot2</strong> are core component packages within the tidyverse and both get loaded as part of the tidyverse.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<p>To demonstrate how these grouping and combining functions work and to illustrate customization of plots, we’ll again use the METABRIC data set.</p>
<pre class="r"><code>metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;)
metabric</code></pre>
<pre><code>## # A tibble: 1,904 x 32
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;          
##  1 MB-0000         1             75.6         140.  LIVING         
##  2 MB-0002         1             43.2          84.6 LIVING         
##  3 MB-0005         1             48.9         164.  DECEASED       
##  4 MB-0006         1             47.7         165.  LIVING         
##  5 MB-0008         1             77.0          41.4 DECEASED       
##  6 MB-0010         1             78.8           7.8 DECEASED       
##  7 MB-0014         1             56.4         164.  LIVING         
##  8 MB-0022         1             89.1          99.5 DECEASED       
##  9 MB-0028         1             86.4          36.6 DECEASED       
## 10 MB-0035         1             84.2          36.3 DECEASED       
## # … with 1,894 more rows, and 27 more variables: Vital_status &lt;chr&gt;,
## #   Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;, Tumour_size &lt;dbl&gt;,
## #   Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;,
## #   HER2_status &lt;chr&gt;, HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;</code></pre>
<hr />
</div>
<div id="grouping-observations" class="section level1">
<h1>Grouping observations</h1>
<div id="summaries-for-groups" class="section level2">
<h2>Summaries for groups</h2>
<p>In the previous session we introduced the <code>summarise()</code> function for computing a summary value for one or more variables from all rows in a table (data frame or tibble). For example, we computed the mean expression of ESR1, the estrogen receptor alpha gene, as follows.</p>
<pre class="r"><code>summarise(metabric, mean(ESR1))</code></pre>
<pre><code>## # A tibble: 1 x 1
##   `mean(ESR1)`
##          &lt;dbl&gt;
## 1         9.61</code></pre>
<p>While the <code>summarise()</code> function is useful on its own, it becomes really powerful when applied to groups of observations within a dataset. For example, we might be more interested in the mean ESR1 expression calculated separately for ER positive and ER negative tumours. We could take each group in turn, filter the data frame to contain only the rows for a given ER status, then apply the <code>summarise()</code> function to compute the mean expression, but that would be somewhat cumbersome. Even more so if we chose to do this for a categorical variable with more than two states, e.g. for each of the integrative clusters. Fortunately, the <strong><code>group_by()</code></strong> function allows this to be done in one simple step.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarise(mean(ESR1))</code></pre>
<pre><code>## # A tibble: 2 x 2
##   ER_status `mean(ESR1)`
##   &lt;chr&gt;            &lt;dbl&gt;
## 1 Negative          6.21
## 2 Positive         10.6</code></pre>
<p>We get an additional column in our output for the categorical variable, <code>ER_status</code>, and a row for each category.</p>
<p>Incidentally, we should expect this result of ER-positive tumours having a higher expression of ESR1 on average than ER-negative tumours. Simple summaries like this are a good way of checking that what we think we know actually holds true in the data we’re looking at. Note that the expression values are on a log<sub>2</sub>scale so ER-positive breast cancers express ESR1 at a level that is approximately 20 times greater, on average, than that of ER-negative tumours.</p>
<pre class="r"><code>2 ** (10.6 - 6.21)  # equivalent to (2 ** 10.6) / (2 ** 6.21)</code></pre>
<pre><code>## [1] 20.96629</code></pre>
<p>Let’s have a look at how ESR1 expression varies between the integrative cluster subtypes defined by the METABRIC study.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(Integrative_cluster) %&gt;%
  summarise(ESR1 = mean(ESR1))</code></pre>
<pre><code>## # A tibble: 11 x 2
##    Integrative_cluster  ESR1
##    &lt;chr&gt;               &lt;dbl&gt;
##  1 1                   10.3 
##  2 10                   6.39
##  3 2                   10.9 
##  4 3                   10.5 
##  5 4ER-                 6.55
##  6 4ER+                 9.78
##  7 5                    7.78
##  8 6                   10.9 
##  9 7                   10.9 
## 10 8                   11.1 
## 11 9                    9.96</code></pre>
<p>As before we can summarize multiple observations, e.g. the mean expression for other genes of interest, this time using the PAM50 classification to define the groups.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50) %&gt;%
  summarise_at(vars(ESR1, PGR, ERBB2), mean)</code></pre>
<pre><code>## # A tibble: 7 x 4
##   PAM50        ESR1   PGR ERBB2
##   &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 Basal        6.42  5.46 10.2 
## 2 claudin-low  7.47  5.60  9.85
## 3 Her2         7.81  5.62 12.6 
## 4 LumA        10.8   6.75 10.7 
## 5 LumB        11.0   6.39 10.6 
## 6 NC          10.9   6.47 10.3 
## 7 Normal       9.50  6.21 10.8</code></pre>
<p>We can also refine our groups by using more than one categorical variable. Let’s subdivide the PAM50 groups by HER2 status to illustrate this.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50, HER2_status) %&gt;%
  summarise(ESR1_mean = mean(ESR1))</code></pre>
<pre><code>## # A tibble: 13 x 3
## # Groups:   PAM50 [7]
##    PAM50       HER2_status ESR1_mean
##    &lt;chr&gt;       &lt;chr&gt;           &lt;dbl&gt;
##  1 Basal       Negative         6.39
##  2 Basal       Positive         6.71
##  3 claudin-low Negative         7.52
##  4 claudin-low Positive         6.80
##  5 Her2        Negative         8.82
##  6 Her2        Positive         7.04
##  7 LumA        Negative        10.8 
##  8 LumA        Positive        10.1 
##  9 LumB        Negative        11.1 
## 10 LumB        Positive        10.2 
## 11 NC          Negative        10.9 
## 12 Normal      Negative         9.68
## 13 Normal      Positive         7.77</code></pre>
<p>It can be quite useful to know how many observations are within each group. We can use a special function, <strong><code>n()</code></strong>, that counts the number of rows rather than computing a summary value from one of the columns.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50, HER2_status) %&gt;%
  summarise(N = n(), ESR1_mean = mean(ESR1))</code></pre>
<pre><code>## # A tibble: 13 x 4
## # Groups:   PAM50 [7]
##    PAM50       HER2_status     N ESR1_mean
##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;     &lt;dbl&gt;
##  1 Basal       Negative      179      6.39
##  2 Basal       Positive       20      6.71
##  3 claudin-low Negative      184      7.52
##  4 claudin-low Positive       15      6.80
##  5 Her2        Negative       95      8.82
##  6 Her2        Positive      125      7.04
##  7 LumA        Negative      658     10.8 
##  8 LumA        Positive       21     10.1 
##  9 LumB        Negative      419     11.1 
## 10 LumB        Positive       42     10.2 
## 11 NC          Negative        6     10.9 
## 12 Normal      Negative      127      9.68
## 13 Normal      Positive       13      7.77</code></pre>
</div>
<div id="counts" class="section level2">
<h2>Counts</h2>
<p>Counting observations within groups is such a common operation that dplyr provides a <strong><code>count()</code></strong> function to do just that. So we could count the number of patient samples in each of the PAM50 classes as follows.</p>
<pre class="r"><code>count(metabric, PAM50)</code></pre>
<pre><code>## # A tibble: 7 x 2
##   PAM50           n
##   &lt;chr&gt;       &lt;int&gt;
## 1 Basal         199
## 2 claudin-low   199
## 3 Her2          220
## 4 LumA          679
## 5 LumB          461
## 6 NC              6
## 7 Normal        140</code></pre>
<p>This is much like the <code>table()</code> function we’ve used several times already to take a quick look at what values are contained in one of the columns in a data frame. They return different data structures however, with <code>count()</code> always returning a data frame (or tibble) that can then be passed to subsequent steps in a ‘piped’ workflow.</p>
<p>If we wanted to subdivide our categories by HER2 status, we can add this as an additional categorical variable just as we did with the previous <code>group_by()</code> examples.</p>
<pre class="r"><code>count(metabric, PAM50, HER2_status)</code></pre>
<pre><code>## # A tibble: 13 x 3
##    PAM50       HER2_status     n
##    &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;
##  1 Basal       Negative      179
##  2 Basal       Positive       20
##  3 claudin-low Negative      184
##  4 claudin-low Positive       15
##  5 Her2        Negative       95
##  6 Her2        Positive      125
##  7 LumA        Negative      658
##  8 LumA        Positive       21
##  9 LumB        Negative      419
## 10 LumB        Positive       42
## 11 NC          Negative        6
## 12 Normal      Negative      127
## 13 Normal      Positive       13</code></pre>
<p>The count column is named ‘n’ by default but you can change this.</p>
<pre class="r"><code>count(metabric, PAM50, HER2_status, name = &quot;Samples&quot;)</code></pre>
<pre><code>## # A tibble: 13 x 3
##    PAM50       HER2_status Samples
##    &lt;chr&gt;       &lt;chr&gt;         &lt;int&gt;
##  1 Basal       Negative        179
##  2 Basal       Positive         20
##  3 claudin-low Negative        184
##  4 claudin-low Positive         15
##  5 Her2        Negative         95
##  6 Her2        Positive        125
##  7 LumA        Negative        658
##  8 LumA        Positive         21
##  9 LumB        Negative        419
## 10 LumB        Positive         42
## 11 NC          Negative          6
## 12 Normal      Negative        127
## 13 Normal      Positive         13</code></pre>
<p><code>count()</code> is equivalent to grouping observations with <code>group_by()</code> and calling <code>summarize()</code> using the special <code>n()</code> function to count the number of rows. So the above statement could have been written in a more long-winded way as follows.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(PAM50, HER2_status) %&gt;%
  summarize(Samples = n())</code></pre>
<p>Summarizing with <code>n()</code> is useful when showing the number of observations in a group alongside a summary value, as we did earlier looking at the mean ESR1 expression within specified groups; it allows you to see if you’re drawing conclusions from only a few data points.</p>
</div>
<div id="missing-values" class="section level2">
<h2>Missing values</h2>
<p>Many summarization functions return <code>NA</code> if any of the values are missing, i.e. the column contains <code>NA</code> values. As an example, we’ll compute the average size of ER-negative and ER-positive tumours.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Average tumour size` = mean(Tumour_size))</code></pre>
<pre><code>## # A tibble: 2 x 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    445                    NA
## 2 Positive   1459                    NA</code></pre>
<p>The <code>mean()</code> function, along with many similar summarization functions, has an <code>na.rm</code> argument that can be set to <code>TRUE</code> to exclude those missing values from the calculation.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Average tumour size` = mean(Tumour_size, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 2 x 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    445                  28.5
## 2 Positive   1459                  25.6</code></pre>
<p>An alternative would be to filter out the observations with missing values but then the number of samples in each ER status group would take on a different meaning, which may or may not be what we actually want.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Tumour_size)) %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Average tumour size` = mean(Tumour_size))</code></pre>
<pre><code>## # A tibble: 2 x 3
##   ER_status     N `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    438                  28.5
## 2 Positive   1446                  25.6</code></pre>
</div>
<div id="counts-and-proportions" class="section level2">
<h2>Counts and proportions</h2>
<p>The <code>sum()</code> and <code>mean()</code> summarization functions are often used with logical values. It might seem surprising to compute a summary for a logical variable but but this turns out to be quite a useful thing to do, for counting the number of <code>TRUE</code> values or obtaining the proportion of values that are <code>TRUE</code>.</p>
<p>Following on from the previous example we could add a column to our summary of average tumour size for ER-positive and ER-negative patients that contains the number of missing values.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), Missing = sum(is.na(Tumour_size)), `Average tumour size` = mean(Tumour_size, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 2 x 4
##   ER_status     N Missing `Average tumour size`
##   &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;                 &lt;dbl&gt;
## 1 Negative    445       7                  28.5
## 2 Positive   1459      13                  25.6</code></pre>
<p>Why does this work? Well, the <code>is.na()</code> function takes a vector and sees which values are <code>NA</code>, returning a logical vector of <code>TRUE</code> where the value was <code>NA</code> and <code>FALSE</code> if not.</p>
<pre class="r"><code>test_vector &lt;- c(1, 3, 2, NA, 6, 5, NA, 10)
is.na(test_vector)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE</code></pre>
<p>The <code>sum()</code> function treats the logical vector as a set of <code>0</code>s and <code>1</code>s where <code>FALSE</code> is <code>0</code> and <code>TRUE</code> is <code>1</code>. In effect <code>sum()</code> counts the number of <code>TRUE</code> values.</p>
<pre class="r"><code>sum(is.na(test_vector))</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Similarly, <code>mean()</code> will compute the proportion of the values that are <code>TRUE</code>.</p>
<pre class="r"><code>mean(is.na(test_vector))</code></pre>
<pre><code>## [1] 0.25</code></pre>
<p>So let’s calculate the number and proportion of samples that do not have a recorded tumour size in each of the ER-negative and ER-positive groups.</p>
<pre class="r"><code>metabric %&gt;%
  group_by(ER_status) %&gt;%
  summarize(N = n(), `Missing tumour size` = sum(is.na(Tumour_size)), `Proportion missing` = mean(is.na(Tumour_size)))</code></pre>
<pre><code>## # A tibble: 2 x 4
##   ER_status     N `Missing tumour size` `Proportion missing`
##   &lt;chr&gt;     &lt;int&gt;                 &lt;int&gt;                &lt;dbl&gt;
## 1 Negative    445                     7              0.0157 
## 2 Positive   1459                    13              0.00891</code></pre>
<p>We can use <code>sum()</code> and <code>mean()</code> for any condition that returns a logical vector. We could, for example, find the number and proportion of patients that survived longer than 10 years (120 months) in each of the ER-negative and ER-positive groups.</p>
<pre class="r"><code>metabric %&gt;%
  filter(Survival_status == &quot;DECEASED&quot;) %&gt;%
  group_by(ER_status) %&gt;%
  summarise(N = n(), N_long_survival = sum(Survival_time &gt; 120), Proportion_long_survival = mean(Survival_time &gt; 120))</code></pre>
<pre><code>## # A tibble: 2 x 4
##   ER_status     N N_long_survival Proportion_long_survival
##   &lt;chr&gt;     &lt;int&gt;           &lt;int&gt;                    &lt;dbl&gt;
## 1 Negative    250              40                    0.16 
## 2 Positive    853             325                    0.381</code></pre>
</div>
<div id="selecting-or-counting-distinct-things" class="section level2">
<h2>Selecting or counting distinct things</h2>
<p>There are occassions when we want to count the number of distinct values in a variable or a combination of variables. In this week’s assignment, we introduce another set of data from the METABRIC study which contains details of the mutations detected by targeted sequencing of a panel of 173 genes. We’ll read this data into R now as this provides a good example of having multiple observations in different rows for a single observational unit, in this case several mutations detected in each tumour sample.</p>
<pre class="r"><code>mutations &lt;- read_csv(&quot;data/metabric_mutations.csv&quot;)
select(mutations, Patient_ID, Chromosome, Position = Start_Position, Ref = Reference_Allele, Alt = Tumor_Seq_Allele1, Type = Variant_Type, Gene)</code></pre>
<pre><code>## # A tibble: 17,272 x 7
##    Patient_ID Chromosome  Position Ref   Alt   Type  Gene 
##    &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
##  1 MTS-T0058  17           7579344 &lt;NA&gt;  &lt;NA&gt;  INS   TP53 
##  2 MTS-T0058  17           7579346 &lt;NA&gt;  &lt;NA&gt;  INS   TP53 
##  3 MTS-T0058  6          168299111 G     G     SNP   MLLT4
##  4 MTS-T0058  22          29999995 G     G     SNP   NF2  
##  5 MTS-T0059  2          198288682 A     A     SNP   SF3B1
##  6 MTS-T0059  6           86195125 T     T     SNP   NT5E 
##  7 MTS-T0059  7           55241717 C     C     SNP   EGFR 
##  8 MTS-T0059  10           6556986 C     C     SNP   PRKCQ
##  9 MTS-T0059  11          62300529 T     T     SNP   AHNAK
## 10 MTS-T0059  15          74912475 G     G     SNP   CLK3 
## # … with 17,262 more rows</code></pre>
<p>We can see from just these few rows that each patient sample has multiple mutations and sometimes there are more than one mutation in the same gene within a sample, as can be seen in the first two rows at the top of the table above.</p>
<p>If we want to count the number of patients in which mutations were detected we could select the distinct set of patient identifiers using the <strong><code>distinct()</code></strong> function.</p>
<pre class="r"><code>mutations %&gt;%
  distinct(Patient_ID) %&gt;%
  nrow()</code></pre>
<pre><code>## [1] 2369</code></pre>
<p>Similarly, we could select the distinct set of mutated genes for each patient as follows.</p>
<pre class="r"><code>mutations %&gt;%
  distinct(Patient_ID, Gene)</code></pre>
<pre><code>## # A tibble: 15,656 x 2
##    Patient_ID Gene 
##    &lt;chr&gt;      &lt;chr&gt;
##  1 MTS-T0058  TP53 
##  2 MTS-T0058  MLLT4
##  3 MTS-T0058  NF2  
##  4 MTS-T0059  SF3B1
##  5 MTS-T0059  NT5E 
##  6 MTS-T0059  EGFR 
##  7 MTS-T0059  PRKCQ
##  8 MTS-T0059  AHNAK
##  9 MTS-T0059  CLK3 
## 10 MTS-T0059  TP53 
## # … with 15,646 more rows</code></pre>
<p>This has reduced the number of rows as only distinct combinations of patient and gene are retained. This would be necessary if we wanted to count the number of patients that have mutations in each gene rather than the number of mutations for that gene regardless of the patient.</p>
<pre class="r"><code># number of mutations for each gene
count(mutations, Gene)</code></pre>
<pre><code>## # A tibble: 173 x 2
##    Gene       n
##    &lt;chr&gt;  &lt;int&gt;
##  1 ACVRL1    20
##  2 AFF2      70
##  3 AGMO      43
##  4 AGTR2     14
##  5 AHNAK    327
##  6 AHNAK2   859
##  7 AKAP9    182
##  8 AKT1     115
##  9 AKT2      23
## 10 ALK       98
## # … with 163 more rows</code></pre>
<pre class="r"><code># number of tumour samples in which each gene is mutated
mutations %&gt;%
  distinct(Patient_ID, Gene) %&gt;%
  count(Gene)</code></pre>
<pre><code>## # A tibble: 173 x 2
##    Gene       n
##    &lt;chr&gt;  &lt;int&gt;
##  1 ACVRL1    20
##  2 AFF2      69
##  3 AGMO      43
##  4 AGTR2     14
##  5 AHNAK    272
##  6 AHNAK2   530
##  7 AKAP9    173
##  8 AKT1     115
##  9 AKT2      23
## 10 ALK       95
## # … with 163 more rows</code></pre>
<p>The genes that differ in these two tables are those that have more than one mutation within a patient tumour sample.</p>
<hr />
</div>
</div>
<div id="joining-data" class="section level1">
<h1>Joining data</h1>
<p>In many real life situations, data are spread across multiple tables or spreadsheets. Usually this occurs because different types of information about a subject, e.g. a patient, are collected from different sources. It may be desirable for some analyses to combine data from two or more tables into a single data frame based on a common column, for example, an attribute that uniquely identifies the subject such as a patient identifier.</p>
<p>dplyr provides a set of join functions for combining two data frames based on matches within specified columns. These operations are very similar to carrying out join operations between tables in a relational database using SQL.</p>
<div id="left_join" class="section level2">
<h2><code>left_join</code></h2>
<p>To illustrate join operations we’ll first consider the most common type, a “left join”. In the schematic below the two data frames share a common column, V1. We can combine the two data frames into a single data frame by matching rows in the first data frame with those in the second data frame that share the same value of variable V1.</p>
<div class="figure">
<img src="images/dplyr_left_join.png" alt="dplyr left join" />
<p class="caption">dplyr left join</p>
</div>
<p><code>left_join()</code> returns all rows from the first data frame regardless of whether there is a match in the second data frame. Rows with no match are included in the resulting data frame but have <code>NA</code> values in the additional columns coming from the second data frame.</p>
<p>Here’s an example in which details about members of the Beatles and Rolling Stones are contained in two tables, using data frames conveniently provided by dplyr (we’ll look at a real example shortly).</p>
<p>The name column identifies each of the band members and is used for matching rows from the two tables.</p>
<pre class="r"><code>band_members</code></pre>
<pre><code>## # A tibble: 3 x 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles</code></pre>
<pre class="r"><code>band_instruments</code></pre>
<pre><code>## # A tibble: 3 x 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Keith guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 3 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass</code></pre>
<p>We have joined the band members and instruments tables based on the common <code>name</code> column. Because this is a left join, only observations for band members in the ‘left’ table (<code>band_members</code>) are included with information brought in from the ‘right’ table (<code>band_instruments</code>) where such exists. There is no entry in <code>band_instruments</code> for Mick so an <code>NA</code> value is inserted into the <code>plays</code> column that gets added in the combined data frame. Keith is only included in the <code>band_instruments</code> data frame so doesn’t make it into the final output as this is based on those band members in the ‘left’ table.</p>
<p><code>right_join()</code> is similar but returns all rows from the second data frame, i.e. the ‘right’ data frame, that have a match with rows in the first data frame.</p>
<pre class="r"><code>right_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 3 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass  
## 3 Keith &lt;NA&gt;    guitar</code></pre>
<p><code>right_join()</code> is used very infrequently compared with <code>left_join()</code>.</p>
</div>
<div id="inner_join" class="section level2">
<h2><code>inner_join</code></h2>
<p>Another joining operation is the “inner join” in which only observations that are common to both data frames are included.</p>
<div class="figure">
<img src="images/dplyr_inner_join.png" alt="dplyr inner join" />
<p class="caption">dplyr inner join</p>
</div>
<pre class="r"><code>inner_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 2 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass</code></pre>
<p>In this case when considering observations identified by <code>name</code>, only John and Paul are contained in both the <code>band_members</code> and <code>band_instruments</code> tables, so only these make it into the combined table.</p>
</div>
<div id="full_join" class="section level2">
<h2><code>full_join</code></h2>
<p>We’ve seen how missing rows from one table can be retained in the joined data frame using <code>left_join</code> or <code>right_join</code> but sometimes data for a given subject may be missing from either of the tables and we still want that subject to appear in the combined table. A <code>full_join</code> will return all rows and all columns from the two tables and where there are no matching values, <code>NA</code> values are used to fill in the missing values.</p>
<div class="figure">
<img src="images/dplyr_full_join.png" alt="dplyr full join" />
<p class="caption">dplyr full join</p>
</div>
<pre class="r"><code>full_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 4 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Keith &lt;NA&gt;    guitar</code></pre>
<p>Now, with <code>full_join()</code>, we have rows for both Mick and Keith even though they are only in one or other of the tables being joined.</p>
</div>
<div id="joining-on-columns-with-different-headers" class="section level2">
<h2>Joining on columns with different headers</h2>
<p>It isn’t uncommon for the columns used for joining two tables to have different names in each table. Of course we could rename one of the two columns, e.g. using the dplyr <code>rename()</code> function, but the dplyr join functions allow you to match using differently-named columns as illustrated using another version of the <code>band_instruments</code> data frame.</p>
<pre class="r"><code>band_instruments2</code></pre>
<pre><code>## # A tibble: 3 x 2
##   artist plays 
##   &lt;chr&gt;  &lt;chr&gt; 
## 1 John   guitar
## 2 Paul   bass  
## 3 Keith  guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments2, by = c(&quot;name&quot; = &quot;artist&quot;))</code></pre>
<pre><code>## # A tibble: 3 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass</code></pre>
<p>The name for the column used for joining is the one given in the first table, i.e. the ‘left’ table, so <code>name</code> rather than <code>artist</code> in this case.</p>
</div>
<div id="multiple-matches-in-join-operations" class="section level2">
<h2>Multiple matches in join operations</h2>
<p>You may be wondering what happens if there are multiple rows in one of both of the two tables for the thing that is being joined, for example what would happen if our second table had two entries for instruments that Paul plays.</p>
<pre class="r"><code>band_instruments3 &lt;- tibble(
  name =  c(&quot;John&quot;,   &quot;Paul&quot;, &quot;Paul&quot;,   &quot;Keith&quot;),
  plays = c(&quot;guitar&quot;, &quot;bass&quot;, &quot;guitar&quot;, &quot;guitar&quot;)
)
band_instruments3</code></pre>
<pre><code>## # A tibble: 4 x 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Paul  guitar
## 4 Keith guitar</code></pre>
<pre class="r"><code>left_join(band_members, band_instruments3, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 4 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Paul  Beatles guitar</code></pre>
<p>We get both entries from the second table added to the first table.</p>
<p>Let’s add an entry for Paul being in a second band and see what happens then when we combine the two tables, each with two entries for Paul.</p>
<pre class="r"><code>band_members3 &lt;- tibble(
  name = c(&quot;Mick&quot;,   &quot;John&quot;,    &quot;Paul&quot;,    &quot;Paul&quot;),
  band = c(&quot;Stones&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Wings&quot;)
)
band_members3</code></pre>
<pre><code>## # A tibble: 4 x 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles
## 4 Paul  Wings</code></pre>
<pre class="r"><code>left_join(band_members3, band_instruments3, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Paul  Beatles guitar
## 5 Paul  Wings   bass  
## 6 Paul  Wings   guitar</code></pre>
<p>The resulting table includes all combinations of band and instrument for Paul.</p>
</div>
<div id="joining-by-matching-on-multiple-columns" class="section level2">
<h2>Joining by matching on multiple columns</h2>
<p>Sometimes the observations being combined are identified by multiple columns, for example, a forename and a surname. We can specify a vector of column names to be used in the join operation.</p>
<pre class="r"><code>band_members4 &lt;- tibble(
  forename = c(&quot;Mick&quot;,   &quot;John&quot;,    &quot;Paul&quot;,      &quot;John&quot;),
  surname =  c(&quot;Jagger&quot;, &quot;Lennon&quot;,  &quot;McCartney&quot;, &quot;Squire&quot;),
  band =     c(&quot;Stones&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;,   &quot;Roses&quot;)
)
band_instruments4 &lt;- tibble(
  forename = c(&quot;John&quot;,   &quot;Paul&quot;,      &quot;Keith&quot;,    &quot;John&quot;),
  surname =  c(&quot;Lennon&quot;, &quot;McCartney&quot;, &quot;Richards&quot;, &quot;Squire&quot;),
  plays =    c(&quot;guitar&quot;, &quot;bass&quot;,      &quot;guitar&quot;,   &quot;guitar&quot;)
)
full_join(band_members4, band_instruments4, by = c(&quot;forename&quot;, &quot;surname&quot;))</code></pre>
<pre><code>## # A tibble: 5 x 4
##   forename surname   band    plays 
##   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick     Jagger    Stones  &lt;NA&gt;  
## 2 John     Lennon    Beatles guitar
## 3 Paul     McCartney Beatles bass  
## 4 John     Squire    Roses   guitar
## 5 Keith    Richards  &lt;NA&gt;    guitar</code></pre>
</div>
<div id="clashing-column-names" class="section level2">
<h2>Clashing column names</h2>
<p>Occasionally we may find that there are duplicated columns in the two tables we want to join, columns that aren’t those used for joining. These variables may even contain different data but happen to have the same name. In such cases dplyr joins add a suffix to each column in the combined table.</p>
<pre class="r"><code>band_members5 &lt;- tibble(
  name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;Ringo&quot;, &quot;George&quot;, &quot;Mick&quot;),
  birth_year = c(1940, 1942, 1940, 1943, 1943),
  band = c(&quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Beatles&quot;, &quot;Stones&quot;)
)
band_instruments5 &lt;- tibble(
  name = c(&quot;John&quot;, &quot;Paul&quot;, &quot;Ringo&quot;, &quot;George&quot;),
  birth_year = c(1940, 1942, 1940, 1943),
  instrument = c(&quot;guitar&quot;, &quot;bass&quot;, &quot;drums&quot;, &quot;guitar&quot;)
)
left_join(band_members5, band_instruments5, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 5 x 5
##   name   birth_year.x band    birth_year.y instrument
##   &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;     
## 1 John           1940 Beatles         1940 guitar    
## 2 Paul           1942 Beatles         1942 bass      
## 3 Ringo          1940 Beatles         1940 drums     
## 4 George         1943 Beatles         1943 guitar    
## 5 Mick           1943 Stones            NA &lt;NA&gt;</code></pre>
<p>It is advisable to rename or remove the duplicated columns that aren’t used for joining.</p>
</div>
<div id="filtering-joins" class="section level2">
<h2>Filtering joins</h2>
<p>A variation on the join operations we’ve considered are <code>semi_join()</code> and <code>anti_join()</code> that filter the rows in one table based on matches or lack of matches to rows in another table.</p>
<p><code>semi_join()</code> returns all rows from the first table where there are matches in the other table.</p>
<pre class="r"><code>semi_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 2 x 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 John  Beatles
## 2 Paul  Beatles</code></pre>
<p><code>anti_join()</code> returns all rows where there is no match in the other table, i.e. those that are unique to the first table.</p>
<pre class="r"><code>anti_join(band_members, band_instruments, by = &quot;name&quot;)</code></pre>
<pre><code>## # A tibble: 1 x 2
##   name  band  
##   &lt;chr&gt; &lt;chr&gt; 
## 1 Mick  Stones</code></pre>
</div>
<div id="a-real-example-joining-the-metabric-clinical-and-mrna-expression-data" class="section level2">
<h2>A real example: joining the METABRIC clinical and mRNA expression data</h2>
<p>Let’s move on to a real example of joining data from two different tables that we used in putting together the combined METABRIC clinical and expression data set.</p>
<p>We first read the clinical data into R and then just select a small number of columns to make it easier to see what is going on when combining the data.</p>
<pre class="r"><code>clinical_data &lt;- read_csv(&quot;data/metabric_clinical_data.csv&quot;)
clinical_data &lt;- select(clinical_data, Patient_ID, ER_status, PAM50)
clinical_data</code></pre>
<pre><code>## # A tibble: 2,509 x 3
##    Patient_ID ER_status PAM50      
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;      
##  1 MB-0000    Positive  claudin-low
##  2 MB-0002    Positive  LumA       
##  3 MB-0005    Positive  LumB       
##  4 MB-0006    Positive  LumB       
##  5 MB-0008    Positive  LumB       
##  6 MB-0010    Positive  LumB       
##  7 MB-0014    Positive  LumB       
##  8 MB-0020    Negative  Normal     
##  9 MB-0022    Positive  claudin-low
## 10 MB-0025    Positive  &lt;NA&gt;       
## # … with 2,499 more rows</code></pre>
<p>We then read in the mRNA expression data that was downloaded separately from <a href="https://www.cbioportal.org/study/summary?id=brca_metabric">cBioPortal</a>.</p>
<pre class="r"><code>mrna_expression_data &lt;- read_tsv(&quot;data/metabric_mrna_expression.txt&quot;)
mrna_expression_data</code></pre>
<pre><code>## # A tibble: 2,509 x 10
##    STUDY_ID      SAMPLE_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##    &lt;chr&gt;         &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 brca_metabric MB-0000    8.93  9.33  5.68  6.34   5.70  6.93  7.95  9.73
##  2 brca_metabric MB-0002   10.0   9.73  7.51  6.19   5.76 11.3  11.8  12.5 
##  3 brca_metabric MB-0005   10.0   9.73  7.38  6.40   6.75  9.29 11.7  10.3 
##  4 brca_metabric MB-0006   10.4  10.3   6.82  6.87   7.22  8.67 11.9  10.5 
##  5 brca_metabric MB-0008   11.3   9.96  7.33  6.34   5.82  9.72 11.6  12.2 
##  6 brca_metabric MB-0010   11.2   9.74  5.95  5.42   6.12  9.79 12.1  11.4 
##  7 brca_metabric MB-0014   10.8   9.28  7.72  5.99   7.48  8.37 11.5  10.8 
##  8 brca_metabric MB-0020   NA    NA    NA    NA     NA    NA    NA    NA   
##  9 brca_metabric MB-0022   10.4   8.61  5.59  6.17   7.59  7.87 10.7   9.95
## 10 brca_metabric MB-0025   NA    NA    NA    NA     NA    NA    NA    NA   
## # … with 2,499 more rows</code></pre>
<p>Now we have both sets of data loaded into R as data frames, we can combine them into a single data frame using an <code>inner_join()</code>. Our resulting table will only contain entries for the patients for which expression data are available.</p>
<pre class="r"><code>combined_data &lt;- inner_join(clinical_data, mrna_expression_data, by = c(&quot;Patient_ID&quot; = &quot;SAMPLE_ID&quot;))
combined_data</code></pre>
<pre><code>## # A tibble: 2,509 x 12
##    Patient_ID ER_status PAM50 STUDY_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3
##    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000    Positive  clau… brca_me…  8.93  9.33  5.68  6.34   5.70  6.93
##  2 MB-0002    Positive  LumA  brca_me… 10.0   9.73  7.51  6.19   5.76 11.3 
##  3 MB-0005    Positive  LumB  brca_me… 10.0   9.73  7.38  6.40   6.75  9.29
##  4 MB-0006    Positive  LumB  brca_me… 10.4  10.3   6.82  6.87   7.22  8.67
##  5 MB-0008    Positive  LumB  brca_me… 11.3   9.96  7.33  6.34   5.82  9.72
##  6 MB-0010    Positive  LumB  brca_me… 11.2   9.74  5.95  5.42   6.12  9.79
##  7 MB-0014    Positive  LumB  brca_me… 10.8   9.28  7.72  5.99   7.48  8.37
##  8 MB-0020    Negative  Norm… brca_me… NA    NA    NA    NA     NA    NA   
##  9 MB-0022    Positive  clau… brca_me… 10.4   8.61  5.59  6.17   7.59  7.87
## 10 MB-0025    Positive  &lt;NA&gt;  brca_me… NA    NA    NA    NA     NA    NA   
## # … with 2,499 more rows, and 2 more variables: FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;</code></pre>
<p>Having combined the data, we can carry out exploratory data analysis using elements from both data sets.</p>
<pre class="r"><code>combined_data %&gt;%
  filter(!is.na(PAM50), !is.na(ESR1)) %&gt;%
  ggplot(mapping = aes(x = PAM50, y = ESR1, colour = PAM50)) +
  geom_boxplot(show.legend = FALSE)</code></pre>
<p><img src="week5_files/figure-html/box_plot_1-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="customizing-plots-with-ggplot2" class="section level1">
<h1>Customizing plots with ggplot2</h1>
<p>Finally, we’ll turn our attention back to visualization using ggplot2 and how we can customize our plots by adding or changing titles and labels, changing the scales used on the x and y axes, and choosing colours.</p>
<div id="titles-and-labels" class="section level2">
<h2>Titles and labels</h2>
<p>Adding titles and subtitles to a plot and changing the x- and y-axis labels is very straightforward using the <code>labs()</code> function.</p>
<pre class="r"><code>plot &lt;- ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  labs(
    title = &quot;mRNA expression in the METABRIC breast cancer data set&quot;,
    subtitle = &quot;GATA3 and ESR1 mRNA expression measured using Illumina HT-12 bead arrays&quot;,
    x = &quot;log2 GATA3 expression&quot;,
    y = &quot;log2 ESR1 expression&quot;,
    colour = &quot;ER status&quot;
  )
plot</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_1-1.png" width="672" /></p>
<p>The labels are another component of the plot object that we’ve constructed, along with aesthetic mappings and layers (geoms). The plot object is a list and contains various elements including those mappings and layers and one element named <code>labels</code>.</p>
<p><code>labs()</code> is a simple function for creating a list of labels you want to specify as name-value pairs as in the above example. You can name any aesthetic (in this case x and y) to override the default values (the column names) and you can add a title, subtitle and caption if you wish. In addition to changing the x- and y-axis labels, we also removed the underscore from the legend title by setting the label for the colour aesthetic.</p>
</div>
<div id="scales" class="section level2">
<h2>Scales</h2>
<p>Take a look at the x and y scales in the above plot. ggplot2 has chosen the x and y scales and where to put breaks and ticks.</p>
<p>Let’s have a look at the elements of the list object we created that specifies how the plot should be displayed.</p>
<pre class="r"><code>names(plot)</code></pre>
<pre><code>## [1] &quot;data&quot;        &quot;layers&quot;      &quot;scales&quot;      &quot;mapping&quot;     &quot;theme&quot;      
## [6] &quot;coordinates&quot; &quot;facet&quot;       &quot;plot_env&quot;    &quot;labels&quot;</code></pre>
<p>One of the components of the plot is called <code>scales</code>. ggplot2 automatically adds default scales behind the scenes equivalent to the following:</p>
<pre class="r"><code>plot &lt;- ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()</code></pre>
<p>Note that we have three aesthetics and ggplot2 adds a scale for each.</p>
<pre class="r"><code>plot$mapping</code></pre>
<pre><code>## Aesthetic mapping: 
## * `x`      -&gt; `GATA3`
## * `y`      -&gt; `ESR1`
## * `colour` -&gt; `ER_status`</code></pre>
<p>The x and y variables (<code>GATA3</code> and <code>ESR1</code>) are continuous so ggplot2 adds a continuous scale for each. <code>ER_status</code> is a discrete variable in this case so ggplot2 adds a discrete scale for colour.</p>
<p>Generalizing, the scales that are required follow the naming scheme:</p>
<pre><code>scale_&lt;NAME_OF_AESTHETIC&gt;_&lt;NAME_OF_SCALE&gt;</code></pre>
<p>Look at the help page for <code>scale_y_continuous</code> to see what we can change about the y-axis scale.</p>
<p>First we’ll change the breaks, i.e. where ggplot2 puts ticks and numeric labels, on the y axis.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(5, 15, by = 2.5))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_2-1.png" width="672" /></p>
<p><code>seq()</code> is a useful function for generating regular sequences of numbers. In this case we wanted numbers from 5 to 15 going up in steps of 2.5.</p>
<pre class="r"><code>seq(5, 15, by = 2.5)</code></pre>
<pre><code>## [1]  5.0  7.5 10.0 12.5 15.0</code></pre>
<p>We could do the same thing for the x axis using <code>scale_x_continuous()</code>.</p>
<p>We can also adjust the extents of the x or y axis.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(5, 15, by = 2.5), limits = c(4, 15))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_3-1.png" width="672" /></p>
<p>We can change the minor breaks, e.g. to add more lines that act as guides. These are shown as thin white lines when using the default theme (we’ll take a look at alternative themes next week).</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(5, 12.5, by = 2.5), minor_breaks = seq(5, 13.5, 0.5), limits = c(5, 13.5))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_4-1.png" width="672" /></p>
<p>Or we can remove the minor breaks entirely.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(6, 14, by = 2), minor_breaks = NULL, limits = c(5, 13.5))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_5-1.png" width="672" /></p>
<p>Similarly we could remove all breaks entirely.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = NULL)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_6-1.png" width="672" /></p>
<p>A more typical scenario would be to keep the breaks, because we want to display the ticks and their lables, but remove the grid lines. Somewhat confusingly the position of grid lines are controlled by a scale but preventing these from being displayed requires changing the theme. The theme controls the way in which non-data components are displayed – we’ll look at how these can be customized next week. For now, though, here’s an example of turning off the display of all grid lines for major and minor breaks for both axes.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_y_continuous(breaks = seq(4, 14, by = 2), limits = c(4, 14)) +
  theme(panel.grid = element_blank())</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_7-1.png" width="672" /></p>
<p>By default, the scales are expanded by 5% of the range on either side. We can add or reduce the space as follows.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_x_continuous(expand = expand_scale(mult = 0.01)) +
  scale_y_continuous(expand = expand_scale(mult = 0.25))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_8-1.png" width="672" /></p>
<p>Here we only added 1% (0.01) of the range of GATA3 expression values on either side along the x axis but we added 25% (0.25) of the range of ESR1 expression on either side along the y axis.</p>
<p>We can move the axis to the other side of the plot –- not sure why you’d want to do this but with ggplot2 just about anything is possible.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_x_continuous(position = &quot;top&quot;)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_9-1.png" width="672" /></p>
</div>
<div id="colours" class="section level2">
<h2>Colours</h2>
<p>The colour asthetic is used with a categorical variable, <code>ER_status</code>, in the scatter plots we’ve been customizing. The default colour scale used by ggplot2 for categorical variables is <code>scale_colour_discrete</code>. We can manually set the colours we wish to use using <code>scale_colour_manual</code> instead.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_colour_manual(values = c(&quot;dodgerblue2&quot;, &quot;firebrick2&quot;))</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_10-1.png" width="672" /></p>
<p>Setting colours manually is ok when we only have two or three categories but when we have a larger number it would be handy to be able to choose from a selection of carefully-constructed colour palettes. Helpfully, ggplot2 provides access to the <a href="http://colorbrewer2.org">ColorBrewer</a> palettes through the functions <code>scale_colour_brewer()</code> and <code>scale_fill_brewer()</code>.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
  geom_point(size = 0.6, alpha = 0.5, na.rm = TRUE) +
  scale_colour_brewer(palette = &quot;Set1&quot;)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_11-1.png" width="672" /></p>
<p>Look at the help page for <code>scale_colour_brewer</code> to see what other colour palettes are available and visit the <a href="http://colorbrewer2.org">ColorBrewer</a> website to see what these look like.</p>
<p>Interestingly, you can set other attributes other than just the colours at the same time.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.6, alpha = 0.5) +
  geom_smooth(method = &quot;lm&quot;) +
  scale_colour_manual(values = c(&quot;dodgerblue2&quot;, &quot;firebrick2&quot;), labels = c(&quot;ER-negative&quot;, &quot;ER-positive&quot;)) +
  labs(colour = NULL)  # remove legend title for colour now that the labels are self-explanatory</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_12-1.png" width="672" /></p>
<p>We have applied our own set of mappings from levels in the data to aesthetic values.</p>
<p>For continuous variables we may wish to be able to change the colours used in the colour gradient. To demonstrate this we’ll correct the Nottingham prognostic index (NPI) values and use this to colour points in the scatter plot of ESR1 vs GATA3 expression on a continuous scale.</p>
<pre class="r"><code># Nottingham_prognostic_index is incorrectly calculated in the data downloaded from cBioPortal
metabric &lt;- mutate(metabric, Nottingham_prognostic_index = 0.02 * Tumour_size + Lymph_node_status + Neoplasm_histologic_grade)
#
metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.5)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_13-1.png" width="672" /></p>
<p>Higher NPI scores correspond to worse prognosis and lower chance of 5 year survival. We’ll emphasize those points on the scatter plot by adjusting our colour scale.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.75) +
  scale_colour_gradient(low = &quot;white&quot;, high = &quot;firebrick2&quot;)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_14-1.png" width="672" /></p>
<p>In some cases it might make sense to specify two colour gradients either side of a mid-point.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.75) +
  scale_colour_gradient2(low = &quot;dodgerblue1&quot;, mid = &quot;grey90&quot;, high = &quot;firebrick1&quot;, midpoint = 4.5)</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_15-1.png" width="672" /></p>
<p>As before we can override the default labels and other aspects of the colour scale within the scale function.</p>
<pre class="r"><code>metabric %&gt;%
  filter(!is.na(Nottingham_prognostic_index)) %&gt;%
  ggplot(mapping = aes(x = GATA3, y = ESR1, colour = Nottingham_prognostic_index)) +
  geom_point(size = 0.5) +
  scale_colour_gradient(
    low = &quot;lightblue&quot;, high = &quot;darkblue&quot;,
    name = &quot;NPI&quot;,
    breaks = 2:6,
    limits = c(1.5, 6.5)
  )</code></pre>
<p><img src="week5_files/figure-html/scatter_plot_16-1.png" width="672" /></p>
<hr />
</div>
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>In this session we have covered the following:</p>
<ul>
<li>Computing summary values for groups of observations</li>
<li>Counting the numbers of observations within categories</li>
<li>Combining data from two tables through join operations</li>
<li>Customizing plots created with ggplot2 by changing labels, scales and colours</li>
</ul>
<hr />
</div>
<div id="assignment" class="section level1">
<h1>Assignment</h1>
<p>Assignment: <a href="assignments/assignment5.Rmd">assignment5.Rmd</a></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
