<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Week 4 – Data manipulation with dplyr</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img style="width: 120px; float: left; margin-top: 0px; margin-right: 20px;" src="images/CRUK_CI_logo.png"/>Introduction to R&nbsp;&nbsp;&nbsp;</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Contents
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="week0.html">Week 0 - Getting ready</a>
    </li>
    <li>
      <a href="week1.html">Week 1 - Introduction to R and RStudio</a>
    </li>
    <li>
      <a href="week2.html">Week 2 - Working with data in R</a>
    </li>
    <li>
      <a href="week3.html">Week 3 - Data visualization with ggplot2</a>
    </li>
    <li>
      <a href="week4.html">Week 4 - Data manipulation using dplyr</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/bioinformatics-core-shared-training/r-intro">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Week 4 – Data manipulation with dplyr</h1>

</div>


<blockquote>
<h4 id="learning-objectives">Learning objectives</h4>
<ul>
<li>Learn the five key <strong>dplyr</strong> functions for manipulating your data
<ul>
<li><strong><code>select()</code></strong> for selecting a subset of variables, i.e. selecting columns in your table</li>
<li><strong><code>filter()</code></strong> for selecting observations based on their values, i.e. selecting rows in your table</li>
<li><strong><code>arrange()</code></strong> for sorting the observations in your table</li>
<li><strong><code>mutate()</code></strong> for creating a new variable or modifying an existing variable</li>
<li><strong><code>summarise()</code></strong> for collapsing values in one of more columns to a single summary value</li>
</ul></li>
<li>Chain operations together into a workflow using pipes</li>
<li>Learn about faceting in ggplot2 to split your data into separate categories and create a series of sub-plots arranged in a grid</li>
</ul>
</blockquote>
<hr />
<div id="data-manipulation-with-dplyr" class="section level1">
<h1>Data manipulation with dplyr</h1>
<p><strong>dplyr</strong> is one of the packages that gets loaded as part of the tidyverse.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<p>dplyr is the Swiss army knife in the tidyverse, providing many useful functions for manipulating tabular data in data frames or tibbles. We’re going to look at the key functions for filtering our data, modifying the contents and computing summary statistics.</p>
<p>We’ll also introduce the pipe operator, <strong><code>%&gt;%</code></strong>, for chaining operations together into mini workflows in a way that makes for more readable and maintainable code.</p>
<p>Finally, we’ll return to plotting and look at a powerful feature of ggplot2, <strong>faceting</strong>, that allows you to divide your plots into subplots by splitting the observations based on one or more categorical variables.</p>
<p>We’ll again use the METABRIC data set to illustrate how these operations work.</p>
<pre class="r"><code>metabric &lt;- read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;)
metabric</code></pre>
<pre><code>## # A tibble: 1,904 x 32
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;          
##  1 MB-0000         1             75.6         140.  LIVING         
##  2 MB-0002         1             43.2          84.6 LIVING         
##  3 MB-0005         1             48.9         164.  DECEASED       
##  4 MB-0006         1             47.7         165.  LIVING         
##  5 MB-0008         1             77.0          41.4 DECEASED       
##  6 MB-0010         1             78.8           7.8 DECEASED       
##  7 MB-0014         1             56.4         164.  LIVING         
##  8 MB-0022         1             89.1          99.5 DECEASED       
##  9 MB-0028         1             86.4          36.6 DECEASED       
## 10 MB-0035         1             84.2          36.3 DECEASED       
## # … with 1,894 more rows, and 27 more variables: Vital_status &lt;chr&gt;,
## #   Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;, Tumour_size &lt;dbl&gt;,
## #   Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;,
## #   HER2_status &lt;chr&gt;, HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;</code></pre>
<hr />
</div>
<div id="data-semantics" class="section level1">
<h1>Data semantics</h1>
<p>We use the terms ‘observation’ and ‘variable’ a lot in this course. As a reminder from week 2, when we talk about an observation, we’re talking about a set of values measured for the same unit or thing, e.g. a person or a date, and when we talk about a variable we are really talking about the attribute that we are measuring or recording, e.g. height, temperature or expression value.</p>
<p><strong>Observations are represented as rows</strong> in our data frames or tibbles, while the <strong>columns correspond to variables</strong>.</p>
<div class="rmdblock">
<p>
From <strong>“Tidy Data”</strong> by <strong>Hadley Wickham</strong>, <a href="https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf"><em>The Journal of Statistical Software</em>, vol. 59, 2014</a>.
</p>
<p>
A data set is a collection of <strong>values</strong>, usually either numbers (if quantitative) or character strings (if qualitative). Values are organised in two ways. Every value belongs to a variable and an observation.
</p>
<p>
A <strong>variable</strong> contains all values that measure the same underlying attribute (like height, temperature, duration) across units.
</p>
<p>
An <strong>observation</strong> contains all values measured on the same unit (like a person or a day) across attributes.
</p>
</div>
<hr />
</div>
<div id="dplyr-verbs" class="section level1">
<h1>dplyr verbs</h1>
<p>We will be looking at the 5 key dplyr functions this week:</p>
<ul>
<li><strong><code>filter()</code></strong> for filtering rows</li>
<li><strong><code>select()</code></strong> for selecting columns</li>
<li><strong><code>arrange()</code></strong> for sorting rows</li>
<li><strong><code>mutate()</code></strong> for modifying columns or creating new ones</li>
<li><strong><code>summarise()</code></strong> for computing summary values</li>
</ul>
<p>In looking at each of these in turn, we’ll be applying these to the entire data set. It is possible to combine these with the <code>group_by()</code> function to instead operate on separate groups within our data set but this is something we’ll cover in detail next week.</p>
<p>The dplyr operations are commonly referred to as “verbs” in a data manipulation grammar. These verbs have a common syntax and work together in a consistent and uniform manner. They all have the following shared behaviours:</p>
<ul>
<li><p>The first argument in each function is a data frame (or tibble)</p></li>
<li><p>Any additional arguments describe what operation to perform on the data frame</p></li>
<li><p>Variable names, i.e. column names, are referred to without using quotes</p></li>
<li><p>The result of an operation is a new data frame</p></li>
</ul>
<hr />
</div>
<div id="filtering-rows-with-filter" class="section level1">
<h1>Filtering rows with <code>filter()</code></h1>
<p>The <strong><code>filter</code></strong> verb allows you to choose rows from a data frame that match some specified criteria. The criteria are based on values of variables and can make use of comparison operators such as <code>==</code>, <code>&gt;</code>, <code>&lt;</code> and <code>!=</code>.</p>
<p>For example, to filter the METABRIC data set so that it only contains observations for those patients who died of breast cancer we can use <code>filter()</code> as follows.</p>
<pre class="r"><code>deceased &lt;- filter(metabric, Vital_status == &quot;Died of Disease&quot;)
deceased</code></pre>
<pre><code>## # A tibble: 622 x 32
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;          
##  1 MB-0005         1             48.9        164.   DECEASED       
##  2 MB-0008         1             77.0         41.4  DECEASED       
##  3 MB-0010         1             78.8          7.8  DECEASED       
##  4 MB-0035         1             84.2         36.3  DECEASED       
##  5 MB-0036         1             85.5        132.   DECEASED       
##  6 MB-0079         1             50.4         28.5  DECEASED       
##  7 MB-0083         1             64.8         86.1  DECEASED       
##  8 MB-0100         1             68.7          8.07 DECEASED       
##  9 MB-0102         1             51.4        141.   DECEASED       
## 10 MB-0108         1             43.2         42.7  DECEASED       
## # … with 612 more rows, and 27 more variables: Vital_status &lt;chr&gt;,
## #   Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;, Tumour_size &lt;dbl&gt;,
## #   Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;,
## #   HER2_status &lt;chr&gt;, HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;</code></pre>
<p>Remember that the <strong><code>==</code></strong> operator tests for equality, i.e. is the value for <code>Vital_status</code> for each patient (observation) equal to “Died of Disease”.</p>
<p>This filtering operation is equivalent to subsetting the rows based on a logical vector resulting from our comparison of vital status values with “Died of Disease”.</p>
<pre class="r"><code>filter(metabric, Vital_status == &quot;Died of Disease&quot;)
# is equivalent to
metabric[metabric$Vital_status == &quot;Died of Disease&quot;, ]</code></pre>
<p>Both achieve the same result but the dplyr filter method is arguably a little easier to read. We haven’t had to write <code>metabric</code> twice for one thing; we just referred to the variable name as it is, unquoted and without any fuss.</p>
<p>Let’s have a look at the various categories in the <code>Vital_status</code> variable.</p>
<pre class="r"><code>table(metabric$Vital_status)</code></pre>
<pre><code>## 
##      Died of Disease Died of Other Causes               Living 
##                  622                  480                  801</code></pre>
<p>We could use the <code>!=</code> comparison operator to select all deceased patients regardless of whether they died of the disease or other causes, by filtering for those that don’t have the value “Living”.</p>
<pre class="r"><code>deceased &lt;- filter(metabric, Vital_status != &quot;Living&quot;)
nrow(deceased)</code></pre>
<pre><code>## [1] 1102</code></pre>
<p>Another way of doing this is to specify which classes we are interested in and use the <strong><code>%in%</code></strong> operator to test which observations (rows) contain those values.</p>
<pre class="r"><code>deceased &lt;- filter(metabric, Vital_status %in% c(&quot;Died of Disease&quot;, &quot;Died of Other Causes&quot;))
nrow(deceased)</code></pre>
<pre><code>## [1] 1102</code></pre>
<p>Another of the tidyverse packages, <strong><code>stringr</code></strong>, contains a set of very useful functions for operating on text or character strings. One such function, <strong><code>str_starts()</code></strong> could be used to find all <code>Vital_status</code> values that start with “Died”.</p>
<pre class="r"><code>deceased &lt;- filter(metabric, str_starts(Vital_status, &quot;Died&quot;))
nrow(deceased)</code></pre>
<pre><code>## [1] 1102</code></pre>
<p>Note that <code>str_starts()</code> returns a logical vector - this is important since the filtering condition must evaluate to <code>TRUE</code> or <code>FALSE</code> values for each row.</p>
<p>Unsurprisingly there is an equivalent function, <code>str_ends()</code>, for matching the end of text (character) values and <code>str_detect()</code> is another useful function that determines whether values match a regular expression. Regular expressions are a language for search patterns used frequently in computer programming and really worth getting to grips with but sadly these are beyond the scope of this course.</p>
<p>Filtering based on a logical variable is the most simple type of filtering of all. We don’t have any logical variables in our METABRIC data set so we’ll create one from the binary <code>Survival_status</code> variable to use as an example.</p>
<pre class="r"><code># create a new logical variable called &#39;Deceased&#39;
metabric$Deceased &lt;- metabric$Survival_status == &quot;DECEASED&quot;
#
# filtering based on a logical variable - only selects TRUE values
deceased &lt;- filter(metabric, Deceased)
#
# only display those columns we&#39;re interested in
deceased[, c(&quot;Patient_ID&quot;, &quot;Survival_status&quot;, &quot;Vital_status&quot;, &quot;Deceased&quot;)]</code></pre>
<pre><code>## # A tibble: 1,103 x 4
##    Patient_ID Survival_status Vital_status         Deceased
##    &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;                &lt;lgl&gt;   
##  1 MB-0005    DECEASED        Died of Disease      TRUE    
##  2 MB-0008    DECEASED        Died of Disease      TRUE    
##  3 MB-0010    DECEASED        Died of Disease      TRUE    
##  4 MB-0022    DECEASED        Died of Other Causes TRUE    
##  5 MB-0028    DECEASED        Died of Other Causes TRUE    
##  6 MB-0035    DECEASED        Died of Disease      TRUE    
##  7 MB-0036    DECEASED        Died of Disease      TRUE    
##  8 MB-0046    DECEASED        Died of Other Causes TRUE    
##  9 MB-0079    DECEASED        Died of Disease      TRUE    
## 10 MB-0083    DECEASED        Died of Disease      TRUE    
## # … with 1,093 more rows</code></pre>
<p>We can use the <strong><code>!</code></strong> operator to filter those patients who are not deceased.</p>
<pre class="r"><code>filter(metabric, !Deceased)</code></pre>
<p>The eagle-eyed will have spotted that filtering on our newly created Deceased logical variable gave a slightly different number of observations (patients) who are considered to be deceased, compared with the filtering operations shown above based on the <code>Vital_status</code> variable. We get one extra row. This is because we have a missing value for the vital status of one of the patients. We can filter for this using the <strong><code>is.na()</code></strong> function.</p>
<pre class="r"><code>missing_vital_status &lt;- filter(metabric, is.na(Vital_status))
missing_vital_status[, c(&quot;Patient_ID&quot;, &quot;Survival_status&quot;, &quot;Vital_status&quot;, &quot;Deceased&quot;)]</code></pre>
<pre><code>## # A tibble: 1 x 4
##   Patient_ID Survival_status Vital_status Deceased
##   &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;        &lt;lgl&gt;   
## 1 MB-5130    DECEASED        &lt;NA&gt;         TRUE</code></pre>
<p><code>filter()</code> only retains rows where the condition if <code>TRUE</code>; both <code>FALSE</code> and <code>NA</code> values are filtered out.</p>
<p>We can apply more than one condition in our filtering operation, for example the patients who were still alive at the time of the METABRIC study and had survived for more than 10 years (120 months).</p>
<pre class="r"><code>filter(metabric, Survival_status == &quot;LIVING&quot;, Survival_time &gt; 120)</code></pre>
<pre><code>## # A tibble: 545 x 33
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;          
##  1 MB-0000         1             75.6          140. LIVING         
##  2 MB-0006         1             47.7          165. LIVING         
##  3 MB-0014         1             56.4          164. LIVING         
##  4 MB-0039         1             70.9          164. LIVING         
##  5 MB-0045         1             45.3          165. LIVING         
##  6 MB-0053         1             70.0          161. LIVING         
##  7 MB-0054         1             66.9          160. LIVING         
##  8 MB-0060         1             45.4          141. LIVING         
##  9 MB-0062         1             52.1          154. LIVING         
## 10 MB-0066         1             61.5          157. LIVING         
## # … with 535 more rows, and 28 more variables: Vital_status &lt;chr&gt;,
## #   Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;, Tumour_size &lt;dbl&gt;,
## #   Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;,
## #   HER2_status &lt;chr&gt;, HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;, Deceased &lt;lgl&gt;</code></pre>
<p>The equivalent using R’s usual subsetting is slightly less readable.</p>
<pre class="r"><code>metabric[metabric$Survival_status == &quot;LIVING&quot; &amp; metabric$Survival_time &gt; 120, ]</code></pre>
<p>We can add as many conditions as we like separating each with a comma. Note that filtering using R subsetting gets more unreadable, and more cumbersome to code, the more conditions you add.</p>
<p>Adding conditions in this way is equivalent to combining the conditions using the <strong><code>&amp;</code></strong> (Boolean AND) operator.</p>
<pre class="r"><code>filter(metabric, Survival_status == &quot;LIVING&quot;, Survival_time &gt; 120)
# is equivalent to
filter(metabric, Survival_status == &quot;LIVING&quot; &amp; Survival_time &gt; 120)</code></pre>
<p>Naturally we can also check when either of two conditions holds true by using the <strong><code>|</code></strong> (Boolean OR) operator. And we can build up more complicated filtering operations using both <code>&amp;</code> and <code>|</code>. For example, let’s see which patients have stage 3 or stage 4 tumours that are either estrogen receptor (ER) positive or progesterone receptor (PR) positive.</p>
<pre class="r"><code>selected_patients &lt;- filter(metabric, Tumour_stage &gt;= 3, ER_status == &quot;Positive&quot; | PR_status == &quot;Positive&quot;)
nrow(selected_patients)</code></pre>
<pre><code>## [1] 79</code></pre>
<p>In this case, if you used <code>&amp;</code> in place of the comma you’d need to be careful about the precedence of the <code>&amp;</code> and <code>|</code> operators and use parentheses to make clear what you intended.</p>
<pre class="r"><code>filter(metabric, Tumour_stage &gt;= 3 &amp; (ER_status == &quot;Positive&quot; | PR_status == &quot;Positive&quot;))</code></pre>
<hr />
</div>
<div id="selecting-columns-with-select" class="section level1">
<h1>Selecting columns with <code>select()</code></h1>
<p>Another way of “slicing and dicing”&quot; our tabular data set is to select just the variables or columns we’re interested in. This can be important particularly when the data set contains a very large number of variables as is the case for the METABRIC data. Notice how when we print the METABRIC data frame it is not possible to display all the columns; we only get the first few and then a long list of the additional ones that weren’t displayed.</p>
<p>Using the <code>$</code> operator is quite convenient for selecting a single column and extracting the values as a vector. Selecting several columns using the <code>[]</code> subsetting operator is a bit more cumbersome. For example, in our look at filtering rows, we considered two different variables in our data set that are concerned with the living/deceased status of patients. When printing out the results we selected just those columns along with the patient identifier and the newly created <code>Deceased</code> column.</p>
<pre class="r"><code>deceased[, c(&quot;Patient_ID&quot;, &quot;Survival_status&quot;, &quot;Vital_status&quot;, &quot;Deceased&quot;)]</code></pre>
<pre><code>## # A tibble: 1,103 x 4
##    Patient_ID Survival_status Vital_status         Deceased
##    &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;                &lt;lgl&gt;   
##  1 MB-0005    DECEASED        Died of Disease      TRUE    
##  2 MB-0008    DECEASED        Died of Disease      TRUE    
##  3 MB-0010    DECEASED        Died of Disease      TRUE    
##  4 MB-0022    DECEASED        Died of Other Causes TRUE    
##  5 MB-0028    DECEASED        Died of Other Causes TRUE    
##  6 MB-0035    DECEASED        Died of Disease      TRUE    
##  7 MB-0036    DECEASED        Died of Disease      TRUE    
##  8 MB-0046    DECEASED        Died of Other Causes TRUE    
##  9 MB-0079    DECEASED        Died of Disease      TRUE    
## 10 MB-0083    DECEASED        Died of Disease      TRUE    
## # … with 1,093 more rows</code></pre>
<p>The <strong><code>select()</code></strong> function from dplyr is simpler.</p>
<pre class="r"><code>select(metabric, Patient_ID, Survival_status, Vital_status, Deceased)</code></pre>
<pre><code>## # A tibble: 1,904 x 4
##    Patient_ID Survival_status Vital_status         Deceased
##    &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;                &lt;lgl&gt;   
##  1 MB-0000    LIVING          Living               FALSE   
##  2 MB-0002    LIVING          Living               FALSE   
##  3 MB-0005    DECEASED        Died of Disease      TRUE    
##  4 MB-0006    LIVING          Living               FALSE   
##  5 MB-0008    DECEASED        Died of Disease      TRUE    
##  6 MB-0010    DECEASED        Died of Disease      TRUE    
##  7 MB-0014    LIVING          Living               FALSE   
##  8 MB-0022    DECEASED        Died of Other Causes TRUE    
##  9 MB-0028    DECEASED        Died of Other Causes TRUE    
## 10 MB-0035    DECEASED        Died of Disease      TRUE    
## # … with 1,894 more rows</code></pre>
<p>Notice the similarities with the <code>filter()</code> function. The first argument is the data frame we are operating on and the arguments that follow on are specific to the operation in question, in this case, the variables (columns) to select. Note that the variables do not need to be put in quotes, and the returned value is another data frame, even if only one column was selected.</p>
<p>We can alter the order of the variables (columns).</p>
<pre class="r"><code>select(metabric, Patient_ID, Vital_status, Survival_status, Deceased)</code></pre>
<pre><code>## # A tibble: 1,904 x 4
##    Patient_ID Vital_status         Survival_status Deceased
##    &lt;chr&gt;      &lt;chr&gt;                &lt;chr&gt;           &lt;lgl&gt;   
##  1 MB-0000    Living               LIVING          FALSE   
##  2 MB-0002    Living               LIVING          FALSE   
##  3 MB-0005    Died of Disease      DECEASED        TRUE    
##  4 MB-0006    Living               LIVING          FALSE   
##  5 MB-0008    Died of Disease      DECEASED        TRUE    
##  6 MB-0010    Died of Disease      DECEASED        TRUE    
##  7 MB-0014    Living               LIVING          FALSE   
##  8 MB-0022    Died of Other Causes DECEASED        TRUE    
##  9 MB-0028    Died of Other Causes DECEASED        TRUE    
## 10 MB-0035    Died of Disease      DECEASED        TRUE    
## # … with 1,894 more rows</code></pre>
<p>We can also select a range of columns using <strong><code>:</code></strong>, e.g. to select the patient identifier and all the columns between <code>Tumour_size</code> and <code>Cancer_type</code> we could run the following <code>select()</code> command.</p>
<pre class="r"><code>select(metabric, Patient_ID, Chemotherapy:Tumour_stage)</code></pre>
<pre><code>## # A tibble: 1,904 x 5
##    Patient_ID Chemotherapy Radiotherapy Tumour_size Tumour_stage
##    &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;
##  1 MB-0000    NO           YES                   22            2
##  2 MB-0002    NO           YES                   10            1
##  3 MB-0005    YES          NO                    15            2
##  4 MB-0006    YES          YES                   25            2
##  5 MB-0008    YES          YES                   40            2
##  6 MB-0010    NO           YES                   31            4
##  7 MB-0014    YES          YES                   10            2
##  8 MB-0022    NO           YES                   29            2
##  9 MB-0028    NO           YES                   16            2
## 10 MB-0035    NO           NO                    28            2
## # … with 1,894 more rows</code></pre>
<p>The help page for <code>select</code> points to some special functions that can be used within <code>select()</code>. We can find all the columns, for example, that contain the term “status” using <code>contains()</code>.</p>
<pre class="r"><code>select(metabric, contains(&quot;status&quot;))</code></pre>
<pre><code>## # A tibble: 1,904 x 7
##    Survival_status Vital_status Lymph_node_stat… ER_status PR_status
##    &lt;chr&gt;           &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;    
##  1 LIVING          Living                      3 Positive  Negative 
##  2 LIVING          Living                      1 Positive  Positive 
##  3 DECEASED        Died of Dis…                2 Positive  Positive 
##  4 LIVING          Living                      2 Positive  Positive 
##  5 DECEASED        Died of Dis…                3 Positive  Positive 
##  6 DECEASED        Died of Dis…                1 Positive  Positive 
##  7 LIVING          Living                      2 Positive  Positive 
##  8 DECEASED        Died of Oth…                2 Positive  Negative 
##  9 DECEASED        Died of Oth…                2 Positive  Negative 
## 10 DECEASED        Died of Dis…                1 Positive  Negative 
## # … with 1,894 more rows, and 2 more variables: HER2_status &lt;chr&gt;,
## #   HER2_status_measured_by_SNP6 &lt;chr&gt;</code></pre>
<p>If we only wanted those ending with “status” we could use <code>ends_with()</code> instead.</p>
<pre class="r"><code>select(metabric, ends_with(&quot;status&quot;))</code></pre>
<pre><code>## # A tibble: 1,904 x 6
##    Survival_status Vital_status Lymph_node_stat… ER_status PR_status
##    &lt;chr&gt;           &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;    
##  1 LIVING          Living                      3 Positive  Negative 
##  2 LIVING          Living                      1 Positive  Positive 
##  3 DECEASED        Died of Dis…                2 Positive  Positive 
##  4 LIVING          Living                      2 Positive  Positive 
##  5 DECEASED        Died of Dis…                3 Positive  Positive 
##  6 DECEASED        Died of Dis…                1 Positive  Positive 
##  7 LIVING          Living                      2 Positive  Positive 
##  8 DECEASED        Died of Oth…                2 Positive  Negative 
##  9 DECEASED        Died of Oth…                2 Positive  Negative 
## 10 DECEASED        Died of Dis…                1 Positive  Negative 
## # … with 1,894 more rows, and 1 more variable: HER2_status &lt;chr&gt;</code></pre>
<p>We can also select those columns we’re not interested in and that shouldn’t be included by prefixing the columns with <strong><code>-</code></strong>.</p>
<pre class="r"><code>select(metabric, -Cohort)</code></pre>
<pre><code>## # A tibble: 1,904 x 32
##    Patient_ID Age_at_diagnosis Survival_time Survival_status Vital_status
##    &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;       
##  1 MB-0000                75.6         140.  LIVING          Living      
##  2 MB-0002                43.2          84.6 LIVING          Living      
##  3 MB-0005                48.9         164.  DECEASED        Died of Dis…
##  4 MB-0006                47.7         165.  LIVING          Living      
##  5 MB-0008                77.0          41.4 DECEASED        Died of Dis…
##  6 MB-0010                78.8           7.8 DECEASED        Died of Dis…
##  7 MB-0014                56.4         164.  LIVING          Living      
##  8 MB-0022                89.1          99.5 DECEASED        Died of Oth…
##  9 MB-0028                86.4          36.6 DECEASED        Died of Oth…
## 10 MB-0035                84.2          36.3 DECEASED        Died of Dis…
## # … with 1,894 more rows, and 27 more variables: Chemotherapy &lt;chr&gt;,
## #   Radiotherapy &lt;chr&gt;, Tumour_size &lt;dbl&gt;, Tumour_stage &lt;dbl&gt;,
## #   Neoplasm_histologic_grade &lt;dbl&gt;, Lymph_nodes_examined_positive &lt;dbl&gt;,
## #   Lymph_node_status &lt;dbl&gt;, Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;,
## #   PR_status &lt;chr&gt;, HER2_status &lt;chr&gt;,
## #   HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;, Deceased &lt;lgl&gt;</code></pre>
<p>You can use a combination of explicit naming, ranges, helper functions and negation to select the columns of interest.</p>
<pre class="r"><code>selected_columns &lt;- select(metabric, Patient_ID, starts_with(&quot;Tumour_&quot;), `3-gene_classifier`:Integrative_cluster, -Cellularity)
selected_columns</code></pre>
<pre><code>## # A tibble: 1,904 x 6
##    Patient_ID Tumour_size Tumour_stage `3-gene_classif… Nottingham_prog…
##    &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;                       &lt;dbl&gt;
##  1 MB-0000             22            2 ER-/HER2-                    6.04
##  2 MB-0002             10            1 ER+/HER2- High …             4.02
##  3 MB-0005             15            2 &lt;NA&gt;                         4.03
##  4 MB-0006             25            2 &lt;NA&gt;                         4.05
##  5 MB-0008             40            2 ER+/HER2- High …             6.08
##  6 MB-0010             31            4 ER+/HER2- High …             4.06
##  7 MB-0014             10            2 &lt;NA&gt;                         4.02
##  8 MB-0022             29            2 &lt;NA&gt;                         4.06
##  9 MB-0028             16            2 ER+/HER2- High …             5.03
## 10 MB-0035             28            2 ER+/HER2- High …             3.06
## # … with 1,894 more rows, and 1 more variable: Integrative_cluster &lt;chr&gt;</code></pre>
<p>You can also use <code>select()</code> to completely reorder the columns so they’re in the order of your choosing. The <code>everything()</code> helper function is useful in this context, particularly if what you’re really interested in is bringing one or more columns to the left hand side and then including everything else afterwards in whatever order they were already in.</p>
<pre class="r"><code>select(metabric, Patient_ID, Survival_status, Tumour_stage, everything())</code></pre>
<pre><code>## # A tibble: 1,904 x 33
##    Patient_ID Survival_status Tumour_stage Cohort Age_at_diagnosis
##    &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt;            &lt;dbl&gt;
##  1 MB-0000    LIVING                     2      1             75.6
##  2 MB-0002    LIVING                     1      1             43.2
##  3 MB-0005    DECEASED                   2      1             48.9
##  4 MB-0006    LIVING                     2      1             47.7
##  5 MB-0008    DECEASED                   2      1             77.0
##  6 MB-0010    DECEASED                   4      1             78.8
##  7 MB-0014    LIVING                     2      1             56.4
##  8 MB-0022    DECEASED                   2      1             89.1
##  9 MB-0028    DECEASED                   2      1             86.4
## 10 MB-0035    DECEASED                   2      1             84.2
## # … with 1,894 more rows, and 28 more variables: Survival_time &lt;dbl&gt;,
## #   Vital_status &lt;chr&gt;, Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;,
## #   Tumour_size &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;,
## #   HER2_status &lt;chr&gt;, HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;, Deceased &lt;lgl&gt;</code></pre>
<p>Finally, columns can be renamed as part of the selection process.</p>
<pre class="r"><code>select(metabric, Patient_ID, Classification = `3-gene_classifier`, NPI = Nottingham_prognostic_index)</code></pre>
<pre><code>## # A tibble: 1,904 x 3
##    Patient_ID Classification          NPI
##    &lt;chr&gt;      &lt;chr&gt;                 &lt;dbl&gt;
##  1 MB-0000    ER-/HER2-              6.04
##  2 MB-0002    ER+/HER2- High Prolif  4.02
##  3 MB-0005    &lt;NA&gt;                   4.03
##  4 MB-0006    &lt;NA&gt;                   4.05
##  5 MB-0008    ER+/HER2- High Prolif  6.08
##  6 MB-0010    ER+/HER2- High Prolif  4.06
##  7 MB-0014    &lt;NA&gt;                   4.02
##  8 MB-0022    &lt;NA&gt;                   4.06
##  9 MB-0028    ER+/HER2- High Prolif  5.03
## 10 MB-0035    ER+/HER2- High Prolif  3.06
## # … with 1,894 more rows</code></pre>
<hr />
</div>
<div id="chaining-operations-using" class="section level1">
<h1>Chaining operations using <code>%&gt;%</code></h1>
<p>Let’s consider again an earlier example in which we filtered the METABRIC data set to retain just the patients who were still alive at the time of the study and had survived for more than 10 years (120 months). We use <code>filter()</code> to select the rows corresponding to the patients meeting these criteria and can then use <code>select()</code> to only display the variables (columns) we’re most interested in.</p>
<pre class="r"><code>patients_of_interest &lt;- filter(metabric, Survival_status == &quot;LIVING&quot;, Survival_time &gt; 120)
patient_details_of_interest &lt;- select(patients_of_interest, Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)
patient_details_of_interest</code></pre>
<pre><code>## # A tibble: 545 x 4
##    Patient_ID Survival_time Tumour_stage Nottingham_prognostic_index
##    &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;                       &lt;dbl&gt;
##  1 MB-0000             140.            2                        6.04
##  2 MB-0006             165.            2                        4.05
##  3 MB-0014             164.            2                        4.02
##  4 MB-0039             164.            1                        2.04
##  5 MB-0045             165.            2                        5.04
##  6 MB-0053             161.            2                        3.05
##  7 MB-0054             160.            2                        4.07
##  8 MB-0060             141.            2                        4.05
##  9 MB-0062             154.            1                        4.03
## 10 MB-0066             157.            2                        4.03
## # … with 535 more rows</code></pre>
<p>Here we’ve used an intermediate variable, <code>patients_of_interest</code>, which we only needed in order to get to the final result. We could just have used the same name to avoid cluttering our environment and overwritten the results from the <code>filter()</code> operation with those of the <code>select()</code> operation.</p>
<pre class="r"><code>patients_of_interest &lt;- select(patients_of_interest, Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)</code></pre>
<p>Another less readable way of writing this code is to nest the <code>filter()</code> function call inside the <code>select()</code>. Although this looks very unwieldy and is not easy to follow, nested function calls are very common in a lot of R code you may come across.</p>
<pre class="r"><code>patients_of_interest &lt;- select(filter(metabric, Survival_status == &quot;LIVING&quot;, Survival_time &gt; 120), Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)
nrow(patients_of_interest)</code></pre>
<pre><code>## [1] 545</code></pre>
<p>However, there is another way chaining together a series of operations into a mini workflow that is elegant, intuitive and makes for very readable R code. For that we need to introduce a new operator, the <strong>pipe</strong> operator, <strong><code>%&gt;%</code></strong>.</p>
<div class="rmdblock">
<p>
<strong>The pipe operator <code>%&gt;%</code></strong>
</p>
<p>
The pipe operator takes the output from one operation, i.e. whatever is on the left-hand side of <code>%&gt;%</code> and passes it in as the first argument to the second operation, or function, on the right-hand side.
</p>
<p>
<strong><code>x %&gt;% f(y)</code></strong> is equivalent to <strong><code>f(x, y)</code></strong>
</p>
<p>
For example:
</p>
<p>
<code>select(starwars, name, height, mass)</code>
</p>
<p>
can be rewritten as
</p>
<p>
<code>starwars %&gt;% select(name, height, mass)</code>
</p>
<p>
This allows for chaining of operations into workflows, e.g.
</p>
<p>
<code>starwars %&gt;%</code><br/>     <code>filter(species == “Droid”) %&gt;%</code><br/>     <code>select(name, height, mass)</code>
</p>
<p>
The <code>%&gt;%</code> operator comes from the <code>magrittr</code> package (do you get the reference?) and is available when we load the tidyverse using <code>library(tidyverse)</code>.
</p>
<p>
Piping in R was motivated by the Unix pipe, <code>|</code>, in which the output from one process is redirected to be the input for the next. This is so named because the flow from one process or operation to the next resembles a pipeline.
</p>
</div>
<p>We can rewrite the code for our filtering and column selection operations as follows.</p>
<pre class="r"><code>patients_of_interest &lt;- metabric %&gt;%
  filter(Survival_status == &quot;LIVING&quot;, Survival_time &gt; 120) %&gt;%
  select(Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)</code></pre>
<p>Note how each operation takes the output from the previous operation as its first argument. This way of coding is embraced wholeheartedly in the tidyverse hence almost every tidyverse function that works on data frames has the data frame as its first argument. It is also the reason why tidyverse functions return a data frame regardless of whether the output could be recast as a vector or a single value.</p>
<p>“Piping”, the act of chaining operations together, becomes really useful when there are several steps involved in filtering and transforming a data set.</p>
<p>The usual way of developing a workflow is to build it up one step at a time, testing the output produced at each stage. Let’s do that for this case.</p>
<p>We start by considering just the patients who are living.</p>
<pre class="r"><code>patients_of_interest &lt;- metabric %&gt;%
  filter(Survival_status == &quot;LIVING&quot;)</code></pre>
<p>We then add another filter for the survival time.</p>
<pre class="r"><code>patients_of_interest &lt;- metabric %&gt;%
  filter(Survival_status == &quot;LIVING&quot;) %&gt;%
  filter(Survival_time &gt; 120)</code></pre>
<p>At each stage we look at the resulting <code>patients_of_interest</code> data frame to check we’re happy with the result.</p>
<p>Finally we only want certain columns, so we add a <code>select()</code> operation.</p>
<pre class="r"><code>patients_of_interest &lt;- metabric %&gt;%
  filter(Survival_status == &quot;LIVING&quot;) %&gt;%
  filter(Survival_time &gt; 120) %&gt;%
  select(Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index)
# print out the result
patients_of_interest</code></pre>
<pre><code>## # A tibble: 545 x 4
##    Patient_ID Survival_time Tumour_stage Nottingham_prognostic_index
##    &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;                       &lt;dbl&gt;
##  1 MB-0000             140.            2                        6.04
##  2 MB-0006             165.            2                        4.05
##  3 MB-0014             164.            2                        4.02
##  4 MB-0039             164.            1                        2.04
##  5 MB-0045             165.            2                        5.04
##  6 MB-0053             161.            2                        3.05
##  7 MB-0054             160.            2                        4.07
##  8 MB-0060             141.            2                        4.05
##  9 MB-0062             154.            1                        4.03
## 10 MB-0066             157.            2                        4.03
## # … with 535 more rows</code></pre>
<p>When continuing our workflow across multiple lines, we need to be careful to ensure the <code>%&gt;%</code> is at the end of the line. If we try to place this at the start of the next line, R will think we’ve finished the workflow prematurely and will report an error at what it considers the next statement, i.e. the line that begins with <code>%&gt;%</code>.</p>
<pre class="r"><code># R considers the following to be 2 separate commands, the first of which ends
# with the first filter operation and runs successfully.
# The second statement is the third and last line, is not a valid commmand and
# so you&#39;ll get an error message
patients_of_interest &lt;- metabric %&gt;%
  filter(Survival_status == &quot;LIVING&quot;)
  %&gt;% filter(Survival_time &gt; 120)</code></pre>
<p>This is very similar to what we saw with adding layers and other components to a ggplot using the <code>+</code> operator, where we needed the <code>+</code> to be at the end of a line.</p>
<p>We’ll be using the pipe <code>%&gt;%</code> operator throughout the rest of the course so you’d better get used to it. But actually we think you’ll come to love it as much as we do.</p>
<hr />
</div>
<div id="sorting-using-arrange" class="section level1">
<h1>Sorting using <code>arrange()</code></h1>
<p>It is sometimes quite useful to sort our data frame based on the values in one or more of the columns, particularly when displaying the contents or saving them to a file. The <code>arrange()</code> function in dplyr provides this sorting capability.</p>
<p>For example, we can sort the METABRIC patients into order of increasing survival time.</p>
<pre class="r"><code>arrange(metabric, Survival_time)</code></pre>
<pre><code>## # A tibble: 1,904 x 33
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;          
##  1 MB-0284         1             51.4         0     LIVING         
##  2 MB-6229         5             75.3         0.1   DECEASED       
##  3 MB-0627         1             54.1         0.767 LIVING         
##  4 MB-0880         1             73.6         1.23  LIVING         
##  5 MB-0125         1             74.0         1.27  LIVING         
##  6 MB-0374         1             34.7         1.43  LIVING         
##  7 MB-0148         1             53.2         1.77  LIVING         
##  8 MB-5525         3             63.2         2     LIVING         
##  9 MB-6092         5             80.6         2.3   DECEASED       
## 10 MB-0117         1             60.1         2.4   LIVING         
## # … with 1,894 more rows, and 28 more variables: Vital_status &lt;chr&gt;,
## #   Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;, Tumour_size &lt;dbl&gt;,
## #   Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;,
## #   HER2_status &lt;chr&gt;, HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;, Deceased &lt;lgl&gt;</code></pre>
<p>Or we might be more interested in the patients that survived the longest so would need the order to be of decreasing survival time. For that we can use the helper function <code>desc()</code> that works specifically with <code>arrange()</code>.</p>
<pre class="r"><code>arrange(metabric, desc(Survival_time))</code></pre>
<pre><code>## # A tibble: 1,904 x 33
##    Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status
##    &lt;chr&gt;       &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;          
##  1 MB-4189         3             61.0          355. DECEASED       
##  2 MB-4079         3             63.2          351  DECEASED       
##  3 MB-0270         1             30.0          337. LIVING         
##  4 MB-4235         3             67.5          336. DECEASED       
##  5 MB-4292         3             58.8          336. DECEASED       
##  6 MB-4212         3             45.5          330. LIVING         
##  7 MB-4548         3             50.4          323. LIVING         
##  8 MB-4633         3             67.0          318. LIVING         
##  9 MB-4332         3             34.4          308. LIVING         
## 10 MB-4418         3             56.1          308. LIVING         
## # … with 1,894 more rows, and 28 more variables: Vital_status &lt;chr&gt;,
## #   Chemotherapy &lt;chr&gt;, Radiotherapy &lt;chr&gt;, Tumour_size &lt;dbl&gt;,
## #   Tumour_stage &lt;dbl&gt;, Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Cancer_type &lt;chr&gt;, ER_status &lt;chr&gt;, PR_status &lt;chr&gt;,
## #   HER2_status &lt;chr&gt;, HER2_status_measured_by_SNP6 &lt;chr&gt;, PAM50 &lt;chr&gt;,
## #   `3-gene_classifier` &lt;chr&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;chr&gt;, Integrative_cluster &lt;chr&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;, Deceased &lt;lgl&gt;</code></pre>
<p>As with the other tidyverse functions and, in particular, the other 4 key dplyr ‘verbs’, <code>arrange()</code> works rather well in workflows in which successive operations are chained using <code>%&gt;%</code>.</p>
<pre class="r"><code>patients_of_interest &lt;- metabric %&gt;%
  filter(Survival_status == &quot;LIVING&quot;) %&gt;%
  filter(Survival_time &gt; 120) %&gt;%
  select(Patient_ID, Survival_time, Tumour_stage, Nottingham_prognostic_index) %&gt;%
  arrange(desc(Survival_time))
# print out the result
patients_of_interest</code></pre>
<pre><code>## # A tibble: 545 x 4
##    Patient_ID Survival_time Tumour_stage Nottingham_prognostic_index
##    &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;                       &lt;dbl&gt;
##  1 MB-0270             337.            2                        4.03
##  2 MB-4212             330.           NA                        3.04
##  3 MB-4548             323.            2                        5.00
##  4 MB-4633             318.            2                        5.05
##  5 MB-4332             308.            1                        4.04
##  6 MB-4418             308.            1                        3.04
##  7 MB-6021             301.           NA                        3   
##  8 MB-4702             301.            2                        4.07
##  9 MB-4839             299.           NA                        1.02
## 10 MB-4735             298.            2                        3.08
## # … with 535 more rows</code></pre>
<p>We can sort by more than one variable by adding more variable arguments to <code>arrange()</code>.</p>
<pre class="r"><code>arrange(patients_of_interest, Tumour_stage, Nottingham_prognostic_index)</code></pre>
<pre><code>## # A tibble: 545 x 4
##    Patient_ID Survival_time Tumour_stage Nottingham_prognostic_index
##    &lt;chr&gt;              &lt;dbl&gt;        &lt;dbl&gt;                       &lt;dbl&gt;
##  1 MB-0230             200.            0                        1.07
##  2 MB-5186             203.            1                        1.02
##  3 MB-0245             165.            1                        1.03
##  4 MB-0318             169.            1                        1.04
##  5 MB-3797             228.            1                        1.05
##  6 MB-4897             197.            1                        2.00
##  7 MB-2721             252.            1                        2.02
##  8 MB-0275             186.            1                        2.02
##  9 MB-2564             285.            1                        2.02
## 10 MB-0244             150.            1                        2.02
## # … with 535 more rows</code></pre>
<p>Here we’ve sorted first by tumour stage from lowest to highest value and then by the Nottingham prognostic index for when there are ties, i.e. where the tumour stage is the same.</p>
<p>Sorting is most commonly used in workflows as one of the last steps before printing out a data frame or writing out the table to a file.</p>
<hr />
</div>
<div id="modifying-data-using-mutate" class="section level1">
<h1>Modifying data using <code>mutate()</code></h1>
<p>In one of the examples of filtering observations using <code>filter()</code> above, we created a new logical variable called <code>Deceased</code>.</p>
<pre class="r"><code>metabric$Deceased &lt;- metabric$Survival_status == &quot;DECEASED&quot;</code></pre>
<p>This is an example of a rather common type of data manipulation in which we crate a new column based on the values contained in one or more other columns. The <code>dplyr</code> package provides the <code>mutate()</code> function for this purpose.</p>
<pre class="r"><code>metabric &lt;- mutate(metabric, Deceased = Survival_status == &quot;DECEASED&quot;)</code></pre>
<p>Both of these methods adds the new column to the end.</p>
<p>Note that variables names in the <code>mutate()</code> function call do not need to be prefixed by <code>metabric$</code> just as they don’t in any of the <code>dplyr</code> functions.</p>
<p>We can overwrite a column and this is quite commonly done when we want to change the units. For example, our tumour size values are in millimetres but the formula for the Nottingham prognostic index needs the tumour size to be in centimetres. We can convert to <code>Tumour_size</code> to centimetres by dividing by 10.</p>
<pre class="r"><code>metabric &lt;- mutate(metabric, Tumour_size = Tumour_size / 10)</code></pre>
<div class="rmdblock">
<p>
<strong>Nottingham Prognostic Index</strong>
</p>
<p>
The Nottingham prognostic index (<strong>NPI</strong>) is used to determine prognosis following surgery for breast cancer. Its value is calculated using three pathological criteria: the size of the tumour, the number of lymph nodes involved, and the grade of the tumour.
</p>
<p>
The formula for the Nottingham prognostic index is:
</p>
<p>
<strong><code>NPI = (0.2 * S) + N + G</code></strong>
</p>
<p>
where
</p>
<ul>
<li>
<strong>S</strong> is the size of the tumour in centimetres
</li>
<li>
<strong>N</strong> is the node status (0 nodes = 1, 1-3 nodes = 2, &gt;3 nodes = 3)
</li>
<li>
<strong>G</strong> is the grade of tumour (Grade I = 1, Grade II = 2, Grade III = 3)
</li>
</ul>
</div>
<p>We’ll recalculate the Nottingham prognostic index using the values <code>Tumour_size</code>, <code>Neoplasm_histologic_grade</code> and <code>Lymph_node_status</code> columns in our METABRIC data frame.</p>
<pre class="r"><code>metabric &lt;- mutate(metabric, NPI = 0.2 * Tumour_size + Lymph_node_status + Neoplasm_histologic_grade)
select(metabric, Tumour_size, Lymph_node_status, Neoplasm_histologic_grade, NPI, Nottingham_prognostic_index)</code></pre>
<pre><code>## # A tibble: 1,904 x 5
##    Tumour_size Lymph_node_status Neoplasm_histolo…   NPI Nottingham_progno…
##          &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt; &lt;dbl&gt;              &lt;dbl&gt;
##  1         2.2                 3                 3  6.44               6.04
##  2         1                   1                 3  4.2                4.02
##  3         1.5                 2                 2  4.3                4.03
##  4         2.5                 2                 2  4.5                4.05
##  5         4                   3                 3  6.8                6.08
##  6         3.1                 1                 3  4.62               4.06
##  7         1                   2                 2  4.2                4.02
##  8         2.9                 2                 2  4.58               4.06
##  9         1.6                 2                 3  5.32               5.03
## 10         2.8                 1                 2  3.56               3.06
## # … with 1,894 more rows</code></pre>
<p>There is a discrepency. Can you see what the problem is?</p>
<p>It appears that the tumour size wasn’t correctly converted into centimetres in the original NPI calculation or that the wrong scaling factor for tumour size was used. This could explain why the plots we created in weeks 1 and 2 featuring the Nottingham prognostic index looked so odd. We’ll see if they look any better with our recalculated values.</p>
<pre class="r"><code>ggplot(data = metabric) +
  geom_point(mapping = aes(x = Age_at_diagnosis, y = NPI), na.rm = TRUE)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_1-1.png" width="672" /></p>
<p>There is still some banding but nothing like the NPI values downloaded from cBioPortal which line up very closely to whole numbers.</p>
<p>The <strong><code>round()</code></strong> function is really useful for rounding numerical values to a specified number of decimal places. We’ll read in the METABRIC data again and create a small workflow that carries out the tumour size conversion, computes the NPI, rounds the tumour size and the resulting NPI value to 1 decimal place and displays the results in decreasing order of NPI.</p>
<pre class="r"><code>read_csv(&quot;data/metabric_clinical_and_expression_data.csv&quot;) %&gt;%
  mutate(Tumour_size = Tumour_size / 10) %&gt;%
  mutate(NPI = 0.2 * Tumour_size + Lymph_node_status + Neoplasm_histologic_grade) %&gt;%
  mutate(Tumour_size = round(Tumour_size, digits = 1)) %&gt;%
  mutate(NPI = round(NPI, digits = 1)) %&gt;%
  arrange(desc(NPI)) %&gt;%
  select(Tumour_size, Lymph_node_status, Neoplasm_histologic_grade, NPI)</code></pre>
<pre><code>## # A tibble: 1,904 x 4
##    Tumour_size Lymph_node_status Neoplasm_histologic_grade   NPI
##          &lt;dbl&gt;             &lt;dbl&gt;                     &lt;dbl&gt; &lt;dbl&gt;
##  1        18                   3                         3   9.6
##  2        16                   3                         3   9.2
##  3        15                   3                         3   9  
##  4        13                   3                         3   8.6
##  5        18.2                 2                         3   8.6
##  6        12                   3                         3   8.4
##  7        10                   3                         3   8  
##  8         9.9                 3                         3   8  
##  9         9.9                 3                         3   8  
## 10         8.4                 3                         3   7.7
## # … with 1,894 more rows</code></pre>
<div id="mutating-multiple-columns" class="section level2">
<h2>Mutating multiple columns</h2>
<p>In that last workflow we included the same rounding operation applied to two different variables. It would be nice to be able to carry out just the one <code>mutate()</code> but apply it to both <code>Tumour_size</code> and <code>NPI</code> columns and we can using <strong><code>mutate_at()</code></strong>.</p>
<pre class="r"><code>metabric %&gt;%
  mutate_at(vars(Tumour_size, NPI), round, digits = 1) %&gt;%
  select(Patient_ID, Tumour_size, NPI)</code></pre>
<pre><code>## # A tibble: 1,904 x 3
##    Patient_ID Tumour_size   NPI
##    &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000            2.2   6.4
##  2 MB-0002            1     4.2
##  3 MB-0005            1.5   4.3
##  4 MB-0006            2.5   4.5
##  5 MB-0008            4     6.8
##  6 MB-0010            3.1   4.6
##  7 MB-0014            1     4.2
##  8 MB-0022            2.9   4.6
##  9 MB-0028            1.6   5.3
## 10 MB-0035            2.8   3.6
## # … with 1,894 more rows</code></pre>
<p>This is slightly more complicated. We had to group the variables for which we want the function to apply using <code>vars()</code>. We then gave the function name as the next argument and finally any additional arguments that the function needs, in this case the number of digits.</p>
<p>We can use the range operator and the same helper functions as we did for selecting columns using <code>select()</code> inside <code>vars()</code>.</p>
<p>For example, we might decide that our expression values are given to a much higher degree of precision than is strictly necessary.</p>
<pre class="r"><code>metabric %&gt;%
  mutate_at(vars(ESR1:MLPH), round, digits = 2) %&gt;%
  select(Patient_ID, ESR1:MLPH)</code></pre>
<pre><code>## # A tibble: 1,904 x 9
##    Patient_ID  ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##    &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 MB-0000     8.93  9.33  5.68  6.34   5.7   6.93  7.95  9.73
##  2 MB-0002    10.0   9.73  7.51  6.19   5.76 11.2  11.8  12.5 
##  3 MB-0005    10.0   9.73  7.38  6.4    6.75  9.29 11.7  10.3 
##  4 MB-0006    10.4  10.3   6.82  6.87   7.22  8.67 11.9  10.5 
##  5 MB-0008    11.3   9.96  7.33  6.34   5.82  9.72 11.6  12.2 
##  6 MB-0010    11.2   9.74  5.95  5.42   6.12  9.79 12.1  11.4 
##  7 MB-0014    10.8   9.28  7.72  5.99   7.48  8.37 11.5  10.8 
##  8 MB-0022    10.4   8.61  5.59  6.17   7.59  7.87 10.7   9.95
##  9 MB-0028    12.5  10.7   5.33  6.22   6.25 10.3  12.2  10.9 
## 10 MB-0035     7.54 11.5   5.59  6.41   5.99 10.2  12.8  13.5 
## # … with 1,894 more rows</code></pre>
<p>Or we could decide that all the columns whose names end with “_status&quot; are in fact categorical variables and should be converted to factors.</p>
<pre class="r"><code>metabric %&gt;%
  mutate_at(vars(ends_with(&quot;_status&quot;)), as.factor) %&gt;%
  select(Patient_ID, ends_with(&quot;_status&quot;))</code></pre>
<pre><code>## # A tibble: 1,904 x 7
##    Patient_ID Survival_status Vital_status Lymph_node_stat… ER_status
##    &lt;chr&gt;      &lt;fct&gt;           &lt;fct&gt;        &lt;fct&gt;            &lt;fct&gt;    
##  1 MB-0000    LIVING          Living       3                Positive 
##  2 MB-0002    LIVING          Living       1                Positive 
##  3 MB-0005    DECEASED        Died of Dis… 2                Positive 
##  4 MB-0006    LIVING          Living       2                Positive 
##  5 MB-0008    DECEASED        Died of Dis… 3                Positive 
##  6 MB-0010    DECEASED        Died of Dis… 1                Positive 
##  7 MB-0014    LIVING          Living       2                Positive 
##  8 MB-0022    DECEASED        Died of Oth… 2                Positive 
##  9 MB-0028    DECEASED        Died of Oth… 2                Positive 
## 10 MB-0035    DECEASED        Died of Dis… 1                Positive 
## # … with 1,894 more rows, and 2 more variables: PR_status &lt;fct&gt;,
## #   HER2_status &lt;fct&gt;</code></pre>
</div>
<div id="anonymous-functions" class="section level2">
<h2>Anonymous functions</h2>
<p>The <code>mutate_at()</code> function, and the related <code>mutate_if()</code> and <code>mutate_all()</code> functions, are really very powerful but with that comes additional complexity.</p>
<p>For example, we may come across situations where we’d like to apply the same operation to multiple columns but where there is no available function in R to do what we want.</p>
<p>Let’s say we want to convert the petal and sepal measurements in the <code>iris</code> data set from centimetres to millimetres. We’d either need to create a new function to do this conversion or we could use what is known as an anonymous function, also known as a lambda expression.</p>
<p>There is no ‘multiply by 10’ function and it seems a bit pointless to create one just for this conversion so we’ll use an anonymous function instead – anonymous because it has no name, it’s an <em>in situ</em> function only used in our <code>mutate_at()</code> function call.</p>
<pre class="r"><code>iris %&gt;%
  as_tibble() %&gt;%
  mutate_at(vars(Sepal.Length:Petal.Width), ~ . * 10)</code></pre>
<pre><code>## # A tibble: 150 x 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  
##  1           51          35           14           2 setosa 
##  2           49          30           14           2 setosa 
##  3           47          32           13           2 setosa 
##  4           46          31           15           2 setosa 
##  5           50          36           14           2 setosa 
##  6           54          39           17           4 setosa 
##  7           46          34           14           3 setosa 
##  8           50          34           15           2 setosa 
##  9           44          29           14           2 setosa 
## 10           49          31           15           1 setosa 
## # … with 140 more rows</code></pre>
<p>The <strong><code>~</code></strong> denotes that we’re using an anonymous function (it is the symbol for formulae in R) and the <code>.</code> is a placeholder for the column being operated on. In this case, we’re multiplying each of the columns between <code>Sepal.Length</code> and <code>Petal.Width</code> inclusive by 10.</p>
<p>If you think this is getting fairly complicated you’d be right. We’ll leave it there for now but point you to the help page for <code>mutate_at</code> if you’re interested in finding out more.</p>
<hr />
</div>
</div>
<div id="computing-summary-values-using-summarise" class="section level1">
<h1>Computing summary values using <code>summarise()</code></h1>
<p>We’ll cover the fifth of the main dplyr ‘verb’ functions, <strong><code>summarise()</code></strong>, only briefly here. This function computes summary values for one or more variables (columns) in a table. Here we will summarise values for the entire table but this function is much more useful in combination with <code>group_by()</code> in working on groups of observations within the data set. We will look at summarizing groups of observations next week.</p>
<p>Any function that calculates a single scalar value from a vector can be used with <code>summarise()</code>. For example, the <code>mean()</code> function calculates the arithmetic mean of a numeric vector. Let’s calculate the average ESR1 expression for tumour samples in the METABRIC data set.</p>
<pre class="r"><code>mean(metabric$ESR1)</code></pre>
<pre><code>## [1] 9.607824</code></pre>
<p>The equivalent operation using <code>summarise()</code> is:</p>
<pre class="r"><code>summarise(metabric, mean(ESR1))</code></pre>
<pre><code>## # A tibble: 1 x 1
##   `mean(ESR1)`
##          &lt;dbl&gt;
## 1         9.61</code></pre>
<p>If you prefer Oxford spelling, in which -ize is preferred to -ise, you’re in luck as dplyr accommodates the alternative spelling.</p>
<p>Both of the above statements gave the same average expression value but these were output in differing formats. The <code>mean()</code> function collapses a vector to single scalar value, which as we know is in fact a vector of length 1. The <code>summarise()</code> function, as with most tidyverse functions, returns another data frame, albeit one in which there is a single row and a single column.</p>
<p>Returning a data frame might be quite useful, particularly if we’re summarising multiple columns or using more than one function, for example computing the average and standard deviation.</p>
<pre class="r"><code>summarise(metabric, ESR1_mean = mean(ESR1), ESR1_sd = sd(ESR1))</code></pre>
<pre><code>## # A tibble: 1 x 2
##   ESR1_mean ESR1_sd
##       &lt;dbl&gt;   &lt;dbl&gt;
## 1      9.61    2.13</code></pre>
<p>Notice how we also named the output columns in this last example.</p>
<div class="rmdblock">
<p>
<strong><code>summarise()</code></strong>
</p>
<p>
<code>summarise()</code> collapses a data frame into a single row by calculating summary values of one or more of the columns.
</p>
<p>
It can take any function that takes a vector of values and returns a single value. Some of the more useful functions include:
</p>
<ul>
<li>
Centre: <strong><code>mean()</code></strong>, <strong><code>median()</code></strong>
</li>
<li>
Spread: <strong><code>sd()</code></strong>, <strong><code>mad()</code></strong>
</li>
<li>
Range: <strong><code>min()</code></strong>, <strong><code>max()</code></strong>, <strong><code>quantile()</code></strong>
</li>
<li>
Position: <strong><code>first()</code></strong>, <strong><code>last()</code></strong>
</li>
<li>
Count: <strong><code>n()</code></strong>
</li>
</ul>
<p>
Note the <code>first()</code>, <code>last()</code> and <code>n()</code> are only really useful when working on groups of observations using <strong><code>group_by()</code></strong>.
</p>
<p>
<strong><code>n()</code></strong> is a special function that returns the number of observations; it doesn’t take a vector argument, i.e. a column.
</p>
</div>
<p>It is also possible to summarise using a function that takes more than one value, i.e. from multiple columns. For example, we could compute the correlation between the expression of FOXA1 and MLPH.</p>
<pre class="r"><code>summarise(metabric, correlation = cor(FOXA1, MLPH))</code></pre>
<pre><code>## # A tibble: 1 x 1
##   correlation
##         &lt;dbl&gt;
## 1       0.898</code></pre>
<div id="summarizing-multiple-columns" class="section level2">
<h2>Summarizing multiple columns</h2>
<p>Much like <code>mutate()</code> with its <code>mutate_at()</code>, <code>mutate_if()</code> and <code>mutate_all()</code> variants, there is a family of <code>summarise()</code> functions similarly named for applying the same summarization function to multiple columns in a single operation. These work in much the same way as their <code>mutate</code> cousins.</p>
<p><strong><code>summarise_at()</code></strong> allows us to select the columns on which to operate using an additional <code>vars()</code> argument.</p>
<pre class="r"><code>summarise_at(metabric, vars(FOXA1, MLPH), mean)</code></pre>
<pre><code>## # A tibble: 1 x 2
##   FOXA1  MLPH
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  10.8  11.4</code></pre>
<p>Selecting the columns is done in the same way as for <code>mutate_at()</code> and <code>select()</code>.</p>
<p><strong><code>summarise_all()</code></strong> summarises values in all columns.</p>
<pre class="r"><code>metabric %&gt;%
  select(ESR1:MLPH) %&gt;%
  summarise_all(mean)</code></pre>
<pre><code>## # A tibble: 1 x 8
##    ESR1 ERBB2   PGR  TP53 PIK3CA GATA3 FOXA1  MLPH
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  9.61  10.8  6.24  6.20   5.97  9.50  10.8  11.4</code></pre>
<p>You have to be careful with <code>summarise_all()</code> that all columns can be summarised with the given summary function. For example, what happens if we try to compute an average of a set of character values?</p>
<pre class="r"><code>summarise_all(metabric, mean, na.rm = TRUE)</code></pre>
<pre><code>## Warning in mean.default(Patient_ID, na.rm = TRUE): argument is not numeric
## or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(Survival_status, na.rm = TRUE): argument is not
## numeric or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(Vital_status, na.rm = TRUE): argument is not
## numeric or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(Chemotherapy, na.rm = TRUE): argument is not
## numeric or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(Radiotherapy, na.rm = TRUE): argument is not
## numeric or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(Cancer_type, na.rm = TRUE): argument is not numeric
## or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(ER_status, na.rm = TRUE): argument is not numeric
## or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(PR_status, na.rm = TRUE): argument is not numeric
## or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(HER2_status, na.rm = TRUE): argument is not numeric
## or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(HER2_status_measured_by_SNP6, na.rm = TRUE):
## argument is not numeric or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(PAM50, na.rm = TRUE): argument is not numeric or
## logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(`3-gene_classifier`, na.rm = TRUE): argument is not
## numeric or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(Cellularity, na.rm = TRUE): argument is not numeric
## or logical: returning NA</code></pre>
<pre><code>## Warning in mean.default(Integrative_cluster, na.rm = TRUE): argument is not
## numeric or logical: returning NA</code></pre>
<pre><code>## # A tibble: 1 x 34
##   Patient_ID Cohort Age_at_diagnosis Survival_time Survival_status
##        &lt;dbl&gt;  &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt;           &lt;dbl&gt;
## 1         NA   2.64             61.1          125.              NA
## # … with 29 more variables: Vital_status &lt;dbl&gt;, Chemotherapy &lt;dbl&gt;,
## #   Radiotherapy &lt;dbl&gt;, Tumour_size &lt;dbl&gt;, Tumour_stage &lt;dbl&gt;,
## #   Neoplasm_histologic_grade &lt;dbl&gt;, Lymph_nodes_examined_positive &lt;dbl&gt;,
## #   Lymph_node_status &lt;dbl&gt;, Cancer_type &lt;dbl&gt;, ER_status &lt;dbl&gt;,
## #   PR_status &lt;dbl&gt;, HER2_status &lt;dbl&gt;,
## #   HER2_status_measured_by_SNP6 &lt;dbl&gt;, PAM50 &lt;dbl&gt;,
## #   `3-gene_classifier` &lt;dbl&gt;, Nottingham_prognostic_index &lt;dbl&gt;,
## #   Cellularity &lt;dbl&gt;, Integrative_cluster &lt;dbl&gt;, Mutation_count &lt;dbl&gt;,
## #   ESR1 &lt;dbl&gt;, ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;,
## #   GATA3 &lt;dbl&gt;, FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;, Deceased &lt;dbl&gt;, NPI &lt;dbl&gt;</code></pre>
<p>We get a lot of warning messages and <code>NA</code> values for those columns for which computing an average does not make sense.</p>
<p><strong><code>summarise_if()</code></strong> can be used to select those values for which a summarization function is appropriate.</p>
<pre class="r"><code>summarise_if(metabric, is.numeric, mean, na.rm = TRUE)</code></pre>
<pre><code>## # A tibble: 1 x 19
##   Cohort Age_at_diagnosis Survival_time Tumour_size Tumour_stage
##    &lt;dbl&gt;            &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;
## 1   2.64             61.1          125.        2.62         1.75
## # … with 14 more variables: Neoplasm_histologic_grade &lt;dbl&gt;,
## #   Lymph_nodes_examined_positive &lt;dbl&gt;, Lymph_node_status &lt;dbl&gt;,
## #   Nottingham_prognostic_index &lt;dbl&gt;, Mutation_count &lt;dbl&gt;, ESR1 &lt;dbl&gt;,
## #   ERBB2 &lt;dbl&gt;, PGR &lt;dbl&gt;, TP53 &lt;dbl&gt;, PIK3CA &lt;dbl&gt;, GATA3 &lt;dbl&gt;,
## #   FOXA1 &lt;dbl&gt;, MLPH &lt;dbl&gt;, NPI &lt;dbl&gt;</code></pre>
<p>It is possible to summarise using more than one function in which case a list of functions needs to be provided.</p>
<pre class="r"><code>summarise_at(metabric, vars(ESR1, ERBB2, PGR), list(mean, sd))</code></pre>
<pre><code>## # A tibble: 1 x 6
##   ESR1_fn1 ERBB2_fn1 PGR_fn1 ESR1_fn2 ERBB2_fn2 PGR_fn2
##      &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1     9.61      10.8    6.24     2.13      1.36    1.02</code></pre>
<p>Pretty neat but I’m not sure about those column headings in the output – fortunately we have some control over these.</p>
<pre class="r"><code>summarise_at(metabric, vars(ESR1, ERBB2, PGR), list(average = mean, stdev = sd))</code></pre>
<pre><code>## # A tibble: 1 x 6
##   ESR1_average ERBB2_average PGR_average ESR1_stdev ERBB2_stdev PGR_stdev
##          &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;
## 1         9.61          10.8        6.24       2.13        1.36      1.02</code></pre>
</div>
<div id="anonymous-functions-1" class="section level2">
<h2>Anonymous functions</h2>
<p>The <code>mutate_</code> functions and <code>summarise_</code> functions work in a very similar manner, very much in line with the coherent and consistent framework provided by <code>dplyr</code> and the entire tidyverse. For example, we could use an anonymous function in a <code>summarise_at()</code> operation applied to multiple variables. In the assignment from last week, we asked you to compute the correlation of the expression for FOXA1 against all other genes to see which was most strongly correlated. Here is how we could do this in a single <code>summarise_at()</code> statement using an anonymous function.</p>
<pre class="r"><code>summarise_at(metabric, vars(ESR1:MLPH, -FOXA1), ~ cor(., FOXA1))</code></pre>
<pre><code>## # A tibble: 1 x 7
##    ESR1 ERBB2   PGR    TP53 PIK3CA GATA3  MLPH
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.724 0.280 0.390 -0.0700 -0.149 0.781 0.898</code></pre>
<p>Notice how we selected all genes between ESR1, the first gene column in our data frame, and MLPH, the last gene column, but then excluded FOXA1 as we’re not all that interested in the correlation of FOXA1 with itself (we know the answer is 1).</p>
<hr />
</div>
</div>
<div id="faceting-with-ggplot2" class="section level1">
<h1>Faceting with ggplot2</h1>
<p>Finally, let’s change tack completely and take a look at a very useful feature of ggplot2 – <strong>faceting</strong>.</p>
<p>Faceting allows you to split your plot into subplots, or facets, based on one or more categorical variables. Each of the subplots displays a subset of the data.</p>
<p>There are two faceting functions, <strong><code>facet_wrap()</code></strong> and <strong><code>facet_grid()</code></strong>.</p>
<p>Let’s create a scatter plot of GATA3 and ESR1 expression values where we’re displaying the PR positive and PR negative patients using different colours. This is a very similar to a plot we created last week.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = PR_status)) +
  geom_point(size = 0.5, alpha = 0.5)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_2-1.png" width="672" /></p>
<p>An alternative is to use faceting with <strong><code>facet_wrap()</code></strong>.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_wrap(~ PR_status)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_3-1.png" width="672" /></p>
<p>This produces two plots, side-by-side, one for each of the categories in the <code>PR_status</code> variable, with a banner across the top of each for the category.</p>
<p>The <code>~ PR_status</code> argument provided to <code>facet_wrap()</code> is known as a formula. Formulae are used to build models in R.</p>
<p>We can still use separate colours if we prefer things to be, well, colourful.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = PR_status)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_wrap(~ PR_status)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_4-1.png" width="672" /></p>
<p>Faceting is usually better than displaying groups using different colours when there are more than two or three groups when it can be difficult to really tell which points belong to each group. A case in point is for the 3-gene classification in the GATA3 vs ESR1 scatter plot we created last week. Let’s create a faceted version of that plot.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_wrap(~ `3-gene_classifier`)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_5-1.png" width="672" /></p>
<p>This helps explain why the function is called <code>facet_wrap()</code>. When it has too many subplots to fit across the page, it wraps around to another row. We can control how many rows or columns to use with the <code>nrow</code> and <code>ncol</code> arguments.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_wrap(~ `3-gene_classifier`, nrow = 1)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_6-1.png" width="672" /></p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = `3-gene_classifier`)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_wrap(~ `3-gene_classifier`, ncol = 2)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_7-1.png" width="672" /></p>
<p>We can combine faceting on one variable with a colour aesthetic for another variable. For example, let’s show the tumour stage status using faceting and the HER2 status using colours.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = HER2_status)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_wrap(~ Neoplasm_histologic_grade)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_8-1.png" width="672" /></p>
<p>Instead of this we could facet on more than variable.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_wrap(~ Neoplasm_histologic_grade + HER2_status)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_9-1.png" width="672" /></p>
<p>Faceting on two variables is usually better done using the other faceting function, <strong><code>facet_grid()</code></strong>. Note the change in how the formula is written.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_grid(Neoplasm_histologic_grade ~ HER2_status)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_10-1.png" width="672" /></p>
<p>Again we can use colour aesthetics alongside faceting to add further information to our visualization.</p>
<pre class="r"><code>ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = PAM50)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_grid(Neoplasm_histologic_grade ~ HER2_status)</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_11-1.png" width="672" /></p>
<p>Finally, we can use a <code>labeller</code> to change the labels for each of the categorical values so that these are more meaningful in the context of this plot.</p>
<pre class="r"><code>grade_labels &lt;- c(&quot;1&quot; = &quot;Grade I&quot;, &quot;2&quot; = &quot;Grade II&quot;, &quot;3&quot; = &quot;Grade III&quot;)
her2_status_labels &lt;- c(&quot;Positive&quot; = &quot;HER2 positive&quot;, &quot;Negative&quot; = &quot;HER2 negative&quot;)

ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = PAM50)) +
  geom_point(size = 0.5, alpha = 0.5) +
  facet_grid(Neoplasm_histologic_grade ~ HER2_status,
             labeller = labeller(
               Neoplasm_histologic_grade = grade_labels,
               HER2_status = her2_status_labels
              )
            )</code></pre>
<p><img src="week4_files/figure-html/scatter_plot_12-1.png" width="672" /></p>
<hr />
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>In this session we have covered the following concepts:</p>
<ul>
<li>Filtering rows in a data frame based on their values</li>
<li>Selecting and reordering of columns</li>
<li>Sorting rows based on values in one or more columns</li>
<li>Modifying a data frame by either adding new columns or modifying existing ones</li>
<li>Summarizing the values in one or more columns</li>
<li>Building up workflows by chaining operations together using the pipe operator</li>
<li>Faceting of ggplot2 visualizations</li>
</ul>
<hr />
</div>
<div id="assignment" class="section level1">
<h1>Assignment</h1>
<p>Assignment: <a href="assignments/assignment4.Rmd">assignment4.Rmd</a></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
